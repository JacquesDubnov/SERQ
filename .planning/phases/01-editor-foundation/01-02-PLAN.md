---
phase: 01-editor-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/components/Editor/EditorToolbar.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle bold/italic/underline via toolbar buttons"
    - "Toolbar buttons show active state when formatting is applied"
    - "User can use Cmd+B, Cmd+I, Cmd+U shortcuts"
    - "User can undo/redo via Cmd+Z, Cmd+Shift+Z"
  artifacts:
    - path: "src/components/Editor/EditorToolbar.tsx"
      provides: "Formatting toolbar with active state"
      contains: "useEditorState"
    - path: "src/App.tsx"
      provides: "Toolbar wired to EditorCore"
      contains: "EditorToolbar"
  key_links:
    - from: "src/components/Editor/EditorToolbar.tsx"
      to: "EditorCore"
      via: "editor prop from getEditor()"
      pattern: "editor\\.chain\\(\\)\\.focus\\(\\)"
    - from: "src/components/Editor/EditorToolbar.tsx"
      to: "TipTap state"
      via: "useEditorState selector"
      pattern: "useEditorState.*selector"
---

<objective>
Create the formatting toolbar with optimized state subscription and verify keyboard shortcuts work.

Purpose: Users need visual controls for formatting and feedback on what formatting is active. The toolbar MUST use useEditorState with selectors to avoid the re-render avalanche pitfall.

Output: Working toolbar with bold/italic/underline/headers/lists, showing active states, plus confirmation that keyboard shortcuts work.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-editor-foundation/01-RESEARCH.md
@.planning/phases/01-editor-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EditorToolbar with useEditorState</name>
  <files>
    - /Users/jacquesdubnov/Coding/serq/src/components/Editor/EditorToolbar.tsx
  </files>
  <action>
Create the formatting toolbar following the research pattern - use useEditorState with selectors to subscribe only to needed state slices:

**src/components/Editor/EditorToolbar.tsx:**
```typescript
import { useEditorState } from '@tiptap/react'
import { Editor } from '@tiptap/core'

interface ToolbarProps {
  editor: Editor
}

export function EditorToolbar({ editor }: ToolbarProps) {
  // CRITICAL: Use selector to avoid re-render avalanche
  const state = useEditorState({
    editor,
    selector: (ctx) => ({
      // Text formatting
      isBold: ctx.editor.isActive('bold'),
      isItalic: ctx.editor.isActive('italic'),
      isUnderline: ctx.editor.isActive('underline'),
      isStrike: ctx.editor.isActive('strike'),
      isCode: ctx.editor.isActive('code'),
      isSubscript: ctx.editor.isActive('subscript'),
      isSuperscript: ctx.editor.isActive('superscript'),

      // Block types
      isParagraph: ctx.editor.isActive('paragraph'),
      isHeading1: ctx.editor.isActive('heading', { level: 1 }),
      isHeading2: ctx.editor.isActive('heading', { level: 2 }),
      isHeading3: ctx.editor.isActive('heading', { level: 3 }),
      isBulletList: ctx.editor.isActive('bulletList'),
      isOrderedList: ctx.editor.isActive('orderedList'),
      isBlockquote: ctx.editor.isActive('blockquote'),
      isCodeBlock: ctx.editor.isActive('codeBlock'),

      // Text alignment
      alignLeft: ctx.editor.isActive({ textAlign: 'left' }),
      alignCenter: ctx.editor.isActive({ textAlign: 'center' }),
      alignRight: ctx.editor.isActive({ textAlign: 'right' }),
      alignJustify: ctx.editor.isActive({ textAlign: 'justify' }),

      // History
      canUndo: ctx.editor.can().undo(),
      canRedo: ctx.editor.can().redo(),
    }),
  })

  // Button component for consistent styling
  const ToolbarButton = ({
    onClick,
    active,
    disabled,
    children,
    title
  }: {
    onClick: () => void
    active?: boolean
    disabled?: boolean
    children: React.ReactNode
    title: string
  }) => (
    <button
      onClick={onClick}
      disabled={disabled}
      title={title}
      className={`
        px-2 py-1.5 rounded text-sm font-medium transition-colors
        ${active
          ? 'bg-gray-200 text-gray-900'
          : 'text-gray-600 hover:bg-gray-100 hover:text-gray-900'
        }
        ${disabled ? 'opacity-40 cursor-not-allowed' : 'cursor-pointer'}
      `}
    >
      {children}
    </button>
  )

  const Divider = () => <div className="w-px h-6 bg-gray-200 mx-1" />

  return (
    <div className="flex items-center gap-0.5 p-2 border-b border-gray-200 bg-white sticky top-0 z-10 flex-wrap">
      {/* History */}
      <ToolbarButton
        onClick={() => editor.chain().focus().undo().run()}
        disabled={!state.canUndo}
        title="Undo (Cmd+Z)"
      >
        ↶
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().redo().run()}
        disabled={!state.canRedo}
        title="Redo (Cmd+Shift+Z)"
      >
        ↷
      </ToolbarButton>

      <Divider />

      {/* Block type dropdown would go here - simplified to buttons for now */}
      <ToolbarButton
        onClick={() => editor.chain().focus().setParagraph().run()}
        active={state.isParagraph}
        title="Paragraph"
      >
        ¶
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
        active={state.isHeading1}
        title="Heading 1"
      >
        H1
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        active={state.isHeading2}
        title="Heading 2"
      >
        H2
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        active={state.isHeading3}
        title="Heading 3"
      >
        H3
      </ToolbarButton>

      <Divider />

      {/* Text formatting */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBold().run()}
        active={state.isBold}
        title="Bold (Cmd+B)"
      >
        <strong>B</strong>
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleItalic().run()}
        active={state.isItalic}
        title="Italic (Cmd+I)"
      >
        <em>I</em>
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleUnderline().run()}
        active={state.isUnderline}
        title="Underline (Cmd+U)"
      >
        <span className="underline">U</span>
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleStrike().run()}
        active={state.isStrike}
        title="Strikethrough"
      >
        <span className="line-through">S</span>
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleCode().run()}
        active={state.isCode}
        title="Inline Code"
      >
        <code>&lt;/&gt;</code>
      </ToolbarButton>

      <Divider />

      {/* Lists */}
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        active={state.isBulletList}
        title="Bullet List"
      >
        •
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleOrderedList().run()}
        active={state.isOrderedList}
        title="Numbered List"
      >
        1.
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleBlockquote().run()}
        active={state.isBlockquote}
        title="Quote"
      >
        "
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().toggleCodeBlock().run()}
        active={state.isCodeBlock}
        title="Code Block"
      >
        {"{ }"}
      </ToolbarButton>

      <Divider />

      {/* Text alignment */}
      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('left').run()}
        active={state.alignLeft}
        title="Align Left"
      >
        ≡
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('center').run()}
        active={state.alignCenter}
        title="Align Center"
      >
        ≡
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('right').run()}
        active={state.alignRight}
        title="Align Right"
      >
        ≡
      </ToolbarButton>
      <ToolbarButton
        onClick={() => editor.chain().focus().setTextAlign('justify').run()}
        active={state.alignJustify}
        title="Justify"
      >
        ≡
      </ToolbarButton>
    </div>
  )
}
```

NOTE: Using text symbols instead of icons for now - can replace with proper icons (lucide-react) in Phase 5 polish. The focus is on functionality and correct state subscription.
  </action>
  <verify>
Import EditorToolbar in App.tsx temporarily to verify it compiles:
```bash
cd /Users/jacquesdubnov/Coding/serq && npm run build
```
Build succeeds without TypeScript errors.
  </verify>
  <done>EditorToolbar component exists with useEditorState selector pattern, all formatting buttons, active state indication.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Toolbar to Editor and Test Shortcuts</name>
  <files>
    - /Users/jacquesdubnov/Coding/serq/src/App.tsx
  </files>
  <action>
Update App.tsx to wire toolbar to editor and verify keyboard shortcuts work:

**src/App.tsx:**
```typescript
import { useRef, useState, useEffect } from 'react'
import { EditorCore, EditorCoreRef } from './components/Editor/EditorCore'
import { EditorToolbar } from './components/Editor/EditorToolbar'
import { Editor } from '@tiptap/core'
import './styles/editor.css'

function App() {
  const editorRef = useRef<EditorCoreRef>(null)
  const [editor, setEditor] = useState<Editor | null>(null)

  // Get editor instance after mount
  useEffect(() => {
    // Small delay to ensure editor is initialized
    const timer = setTimeout(() => {
      const editorInstance = editorRef.current?.getEditor()
      if (editorInstance) {
        setEditor(editorInstance)
      }
    }, 0)
    return () => clearTimeout(timer)
  }, [])

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      {/* Toolbar - only render when editor is ready */}
      {editor && <EditorToolbar editor={editor} />}

      {/* Editor canvas */}
      <main className="flex-1 bg-white">
        <div className="max-w-4xl mx-auto py-8 px-4">
          <EditorCore
            ref={editorRef}
            initialContent="<p>Start writing your document...</p>"
            onUpdate={(html) => {
              // Will wire to dirty state in Plan 04
              console.log('Content updated:', html.length, 'chars')
            }}
            onSelectionChange={() => {
              // Toolbar updates automatically via useEditorState
            }}
          />
        </div>
      </main>
    </div>
  )
}

export default App
```

The keyboard shortcuts (Cmd+B, Cmd+I, Cmd+U, Cmd+Z, Cmd+Shift+Z) are built into TipTap's StarterKit and Underline extension - no additional configuration needed. They work automatically when the editor has focus.

Test each shortcut:
- Cmd+B: Toggle bold
- Cmd+I: Toggle italic
- Cmd+U: Toggle underline (from Underline extension)
- Cmd+Z: Undo
- Cmd+Shift+Z: Redo
- Cmd+Shift+7: Toggle ordered list
- Cmd+Shift+8: Toggle bullet list
  </action>
  <verify>
```bash
cd /Users/jacquesdubnov/Coding/serq && npm run tauri dev
```
1. Toolbar appears above editor
2. Click Bold button - text becomes bold, button shows active state
3. Select bold text, click Bold - text unbolds, button shows inactive
4. Type some text, use Cmd+B - toggles bold
5. Use Cmd+I, Cmd+U - toggles italic/underline
6. Make changes, Cmd+Z - undoes, redo button becomes active
7. Cmd+Shift+Z - redoes

React DevTools: EditorToolbar should ONLY re-render when the subscribed state actually changes, not on every keystroke.
  </verify>
  <done>
Toolbar wired to editor with:
- All formatting buttons functional
- Active states reflecting current selection
- Keyboard shortcuts working (Cmd+B/I/U/Z)
- useEditorState preventing render avalanche
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Formatting test:**
- Type "Hello World"
- Select "Hello", click Bold - word becomes bold
- Select "World", press Cmd+I - word becomes italic
- Click H1 button - line becomes heading
- Undo twice - text returns to plain paragraph

2. **Active state test:**
- Place cursor in bold text - Bold button shows active (darker background)
- Place cursor in normal text - Bold button shows inactive
- Headings, lists, blockquote all show correct active state

3. **Performance test:**
Open React DevTools Profiler:
- Type rapidly for 10 seconds
- EditorToolbar component should only show re-renders when you change formatting or move cursor between differently-formatted text, NOT on every keystroke
</verification>

<success_criteria>
- Toolbar visible with all formatting options
- Button clicks apply formatting to selection
- Active states correctly reflect current cursor position
- Keyboard shortcuts work: Cmd+B, Cmd+I, Cmd+U, Cmd+Z, Cmd+Shift+Z
- useEditorState selector pattern prevents unnecessary re-renders
</success_criteria>

<output>
After completion, create `.planning/phases/01-editor-foundation/01-02-SUMMARY.md`
</output>
