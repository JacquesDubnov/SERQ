---
phase: 03-style-system
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/App.tsx
  - src/components/Editor/EditorToolbar.tsx
  - src/components/Editor/Editor.tsx
  - src/hooks/useFileOperations.ts
  - src/styles/editor.css
autonomous: false

must_haves:
  truths:
    - "User can open style panel via toolbar button"
    - "User can toggle light/dark mode from header"
    - "Document loads with correct style from metadata"
    - "Document saves with current style in metadata"
    - "Style changes trigger auto-save"
    - "Editor uses CSS variables for all colors and typography"
    - "Editor uses CSS variables for layout (margins, spacing, width)"
    - "Format painter applies format when user clicks in editor while active"
  artifacts:
    - path: "src/App.tsx"
      provides: "Wired app with style panel and theme toggle"
      contains: "StylePanel"
    - path: "src/components/Editor/EditorToolbar.tsx"
      provides: "Toolbar with style panel toggle and format painter"
      contains: "FormatPainter"
    - path: "src/components/Editor/Editor.tsx"
      provides: "Editor with format painter click handler"
      contains: "formatPainter"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/StylePanel/StylePanel.tsx"
      via: "render and state management"
      pattern: "StylePanel"
    - from: "src/hooks/useFileOperations.ts"
      to: "src/stores/styleStore.ts"
      via: "load/save style metadata"
      pattern: "loadFromDocument|getStyleMetadata"
    - from: "src/components/Editor/Editor.tsx"
      to: "src/stores/styleStore.ts"
      via: "format painter click detection"
      pattern: "formatPainter\\.active.*applyFormat"
---

<objective>
Wire all style system components into the app and verify end-to-end functionality.

Purpose: Connect the style panel, format painter, theme detection, and document persistence into a working system. Update editor CSS to use CSS variables so presets actually change the document appearance. Wire format painter to detect clicks in editor and apply formatting.

Output: Fully functional style system ready for human verification

Note: Per-section backgrounds (CANV-04) is deferred to Phase 4 - requires TipTap custom node work.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-style-system/03-03-SUMMARY.md
@src/App.tsx
@src/components/Editor/EditorToolbar.tsx
@src/components/Editor/Editor.tsx
@src/hooks/useFileOperations.ts
@src/styles/editor.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Editor CSS to Use Variables</name>
  <files>src/styles/editor.css</files>
  <action>
Replace hardcoded color and typography values with CSS variables.

**Typography updates:**
```css
.editor-content .tiptap {
  font-family: var(--font-body);
  font-size: var(--font-size-base);
  line-height: var(--line-height-body);
  color: var(--color-text-primary);
}

.editor-content .tiptap h1 {
  font-family: var(--font-heading);
  font-size: var(--font-size-h1);
  line-height: var(--line-height-heading);
  letter-spacing: var(--letter-spacing-heading);
}
/* ... same for h2, h3 */

.editor-content .tiptap p {
  font-size: var(--font-size-base);
  line-height: var(--line-height-body);
  color: var(--color-text-primary);
}
```

**Color updates:**
```css
.editor-content .tiptap code {
  background-color: var(--color-code-bg);
  color: var(--color-code-text);
}

.editor-content .tiptap blockquote {
  border-left-color: var(--color-blockquote-border);
  color: var(--color-blockquote-text);
}

.editor-content .tiptap a {
  color: var(--color-link);
}

.editor-content .tiptap mark {
  background-color: var(--color-highlight);
}

.editor-content .tiptap ::selection {
  background-color: var(--color-accent);
  opacity: 0.3;
}
```

**Canvas updates:**
```css
.canvas-container {
  background-color: var(--canvas-bg-color);
  background-image: var(--canvas-bg-image);
  background-size: var(--canvas-bg-size);
  background-position: var(--canvas-bg-position);
  background-repeat: var(--canvas-bg-repeat);
}
```

**Layout updates (NEW - for STYLE-03):**
```css
.editor-content .tiptap {
  max-width: var(--layout-page-max-width);
  padding: var(--layout-page-padding);
  margin-top: var(--layout-margin-top);
  margin-bottom: var(--layout-margin-bottom);
  margin-left: var(--layout-margin-left);
  margin-right: var(--layout-margin-right);
}

.editor-content .tiptap p {
  text-align: var(--layout-text-align);
  margin-bottom: var(--layout-paragraph-spacing);
  text-indent: var(--layout-paragraph-indent);
}

.editor-content .tiptap h1,
.editor-content .tiptap h2,
.editor-content .tiptap h3 {
  margin-top: var(--layout-heading-margin-top);
  margin-bottom: var(--layout-heading-margin-bottom);
}

.editor-content .tiptap ul,
.editor-content .tiptap ol {
  padding-left: var(--layout-list-indent);
}

.editor-content .tiptap blockquote {
  padding-left: var(--layout-blockquote-indent);
}
```

**App chrome updates (header, toolbar):**
```css
/* In appropriate location */
header {
  background-color: var(--color-bg-surface);
  border-color: var(--color-border);
}
```

**Format painter cursor:**
```css
.format-painter-active {
  cursor: copy;
}
/* Or with custom cursor:
.format-painter-active {
  cursor: url('/paintbrush.cur') 0 16, copy;
}
*/
```
  </action>
  <verify>Change a CSS variable in browser dev tools, verify editor styling updates immediately.</verify>
  <done>All editor typography, colors, and layout use CSS variables, changing a preset visually updates the editor</done>
</task>

<task type="auto">
  <name>Task 2: Wire App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Integrate style panel, theme toggle, and style initialization.

**Add imports:**
```typescript
import { StylePanel } from './components/StylePanel'
import { useStyleStore } from './stores'
import { useSystemTheme } from './hooks'
```

**Add state for panel visibility:**
```typescript
const [isStylePanelOpen, setIsStylePanelOpen] = useState(false)
```

**Use system theme hook:**
```typescript
const { effectiveTheme, toggleTheme, setUserOverride } = useSystemTheme()
```

**Initialize styles on mount:**
```typescript
useEffect(() => {
  // Load user defaults from preferences and apply
  // This runs once on app start
  const initStyles = async () => {
    const defaults = await getStyleDefaults()
    useStyleStore.getState().setTypography(defaults.typography)
    useStyleStore.getState().setColor(defaults.colors)
    useStyleStore.getState().setCanvas(defaults.canvas)
    useStyleStore.getState().setLayout(defaults.layout)  // NEW
  }
  initStyles()
}, [])
```

**Add to header:**
- Theme toggle button (sun/moon icon)
- Style panel toggle button (paintbrush or palette icon)

```tsx
<button onClick={toggleTheme} title="Toggle theme">
  {effectiveTheme === 'light' ? '‚òÄÔ∏è' : 'üåô'}
</button>
<button onClick={() => setIsStylePanelOpen(!isStylePanelOpen)} title="Styles">
  üé®
</button>
```

**Render StylePanel:**
```tsx
<StylePanel
  isOpen={isStylePanelOpen}
  onClose={() => setIsStylePanelOpen(false)}
/>
```

**Main content margin when panel open:**
```tsx
<main className={`flex-1 overflow-auto ${isStylePanelOpen ? 'mr-80' : ''}`}>
```
  </action>
  <verify>Run app, click style panel button, panel should slide in. Click theme toggle, colors should switch.</verify>
  <done>App has style panel toggle, theme toggle, styles initialize on mount (including layout)</done>
</task>

<task type="auto">
  <name>Task 3: Wire File Operations</name>
  <files>src/hooks/useFileOperations.ts</files>
  <action>
Update file operations to load and save style metadata.

**On openFile:**
After parsing the document, load styles:
```typescript
const { html, metadata } = parseSerqDocument(content)

// Load document styles (or apply defaults if none)
if (metadata.presets) {
  useStyleStore.getState().loadFromDocument(metadata)
} else {
  // Legacy document - apply user defaults
  const defaults = await getStyleDefaults()
  useStyleStore.getState().setTypography(defaults.typography)
  useStyleStore.getState().setColor(defaults.colors)
  useStyleStore.getState().setCanvas(defaults.canvas)
  useStyleStore.getState().setLayout(defaults.layout)  // NEW
}

editor.commands.setContent(html)
```

**On saveFile/saveFileAs:**
Include style metadata in serialization:
```typescript
const styleMetadata = useStyleStore.getState().getStyleMetadata()
const content = serializeSerqDocument(html, { name, path }, styleMetadata)
```

**On newFile:**
Apply user defaults (fresh document gets user's preferred style):
```typescript
const defaults = await getStyleDefaults()
useStyleStore.getState().setTypography(defaults.typography)
useStyleStore.getState().setColor(defaults.colors)
useStyleStore.getState().setCanvas(defaults.canvas)
useStyleStore.getState().setLayout(defaults.layout)  // NEW
// ... etc
```

**Style changes trigger dirty:**
In styleStore's set* actions, call `useEditorStore.getState().markDirty()`:
```typescript
setTypography: (presetId) => {
  applyTypographyPreset(presetId)
  set({ currentTypography: presetId, ... })
  useEditorStore.getState().markDirty()  // Trigger auto-save
}
```
  </action>
  <verify>Open a styled document, verify styles apply. Change style, save, reopen. Verify style persisted.</verify>
  <done>Opening documents loads their styles (including layout), saving documents persists current styles, new documents get user defaults</done>
</task>

<task type="auto">
  <name>Task 4: Wire Toolbar and Format Painter Editor Integration</name>
  <files>src/components/Editor/EditorToolbar.tsx, src/components/Editor/Editor.tsx</files>
  <action>
Add Format Painter to the toolbar AND wire editor click handler for format painter application.

**EditorToolbar.tsx - Add import:**
```typescript
import { FormatPainter } from '../FormatPainter'
```

**EditorToolbar.tsx - Add to toolbar (after alignment buttons):**
```tsx
<Divider />

{/* Format Painter */}
<FormatPainter editor={editor} />
```

**Editor.tsx - Wire format painter click detection (CRITICAL - fixes warning):**

The FormatPainter component is created but the editor doesn't know when to apply the format. Add click handler to Editor component:

```typescript
import { useStyleStore } from '../../stores'
import { useFormatPainter } from '../../hooks'

// Inside Editor component:
const formatPainter = useStyleStore(state => state.formatPainter)
const { applyFormat, deactivate } = useFormatPainter(editor)

// Add useEffect to handle clicks while format painter is active:
useEffect(() => {
  if (!editor || !formatPainter.active) return

  // When format painter is active, next click in editor applies format
  const handleClick = () => {
    if (formatPainter.active && formatPainter.storedFormat) {
      applyFormat()
      // In toggle mode, stay active. In hold mode, deactivate is handled by key release
      if (formatPainter.mode === 'toggle') {
        // Stay active for next click (user deactivates manually)
      }
    }
  }

  // Attach to editor's DOM element
  const editorElement = editor.view.dom
  editorElement.addEventListener('click', handleClick)

  return () => {
    editorElement.removeEventListener('click', handleClick)
  }
}, [editor, formatPainter.active, formatPainter.storedFormat, applyFormat])
```

**Alternative approach using TipTap's transaction handling:**
```typescript
// If click approach is flaky, use selection change instead:
useEffect(() => {
  if (!editor || !formatPainter.active) return

  const handleSelectionUpdate = () => {
    // Apply format when selection changes (user clicked somewhere)
    if (formatPainter.active && formatPainter.storedFormat && !editor.state.selection.empty) {
      applyFormat()
    }
  }

  editor.on('selectionUpdate', handleSelectionUpdate)
  return () => editor.off('selectionUpdate', handleSelectionUpdate)
}, [editor, formatPainter.active, formatPainter.storedFormat, applyFormat])
```

**Register keyboard shortcut for style panel:**
Using react-hotkeys-hook in App.tsx or a dedicated hook:
```typescript
useHotkeys('mod+shift+y', (e) => {
  e.preventDefault()
  setIsStylePanelOpen(prev => !prev)
}, { enableOnContentEditable: true })
```

Note: Cmd+Shift+S is Save As. Use Cmd+Shift+Y for style panel.
  </action>
  <verify>Format painter button appears in toolbar. Click it on bold text, then click plain text. Plain text becomes bold.</verify>
  <done>Format painter in toolbar AND editor detects when format painter is active and applies format on click. Keyboard shortcut opens style panel.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete style system with presets, panel UI, format painter, and persistence</what-built>
  <how-to-verify>
**Test 1: Typography Presets**
1. Open SERQ
2. Type some text with headings and paragraphs
3. Open style panel (click palette icon or Cmd+Shift+Y)
4. Click different typography presets
5. Verify: Document typography changes instantly

**Test 2: Color Schemes**
1. Expand Colors section in style panel
2. Click different color presets
3. Verify: Text colors, backgrounds, accents update instantly

**Test 3: Light/Dark Mode**
1. Click theme toggle in header (sun/moon)
2. Verify: Colors invert appropriately
3. Change macOS System Settings > Appearance
4. Verify: App follows system (if set to system mode)

**Test 4: Canvas Backgrounds**
1. Expand Canvas section in style panel
2. Try solid colors, gradients, patterns
3. Verify: Canvas background changes

**Test 5: Layout Presets (NEW - STYLE-03)**
1. Expand Layout section in style panel
2. Try different layout presets (Narrow, Wide, Centered, etc.)
3. Verify: Page margins, max-width, text alignment change

**Test 6: Master Themes (NEW - STYLE-04)**
1. Expand Master Themes section in style panel
2. Click a master theme (e.g., "Novelist", "Academic", "Night Owl")
3. Verify: All four presets (typography + colors + canvas + layout) change together
4. Verify: Individual preset sections show the new values

**Test 7: Format Painter**
1. Type "Hello World" in editor
2. Bold "Hello"
3. Select "Hello", click format painter button
4. Select "World", click in document
5. Verify: "World" becomes bold

**Test 8: Persistence**
1. Apply a non-default style (e.g., Modern Sans + Sepia + Narrow layout)
2. Save document (Cmd+S)
3. Close and reopen the document
4. Verify: Styles are restored (including layout)

**Test 9: Style Panel UX**
1. Verify panel slides in from right
2. Verify content area shifts left (panel pushes, not overlays)
3. Verify accordion sections work (one at a time)
4. Verify Recently Used shows previously used presets
5. Verify 5 sections exist: Master Themes, Typography, Colors, Canvas, Layout
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. CSS variables control editor appearance (typography, colors, layout)
2. Style panel opens/closes with animation
3. Preset clicks update document instantly
4. Theme toggle switches light/dark
5. Format painter copies and applies formatting (editor click detection works)
6. File save/load preserves styles (including layout)
7. Auto-save triggers on style change
8. Layout presets affect margins, width, spacing
9. Master themes apply all four preset types at once
</verification>

<success_criteria>
- [ ] All editor typography uses CSS variables
- [ ] All editor colors use CSS variables
- [ ] Canvas background uses CSS variables
- [ ] Layout uses CSS variables (margins, max-width, spacing)
- [ ] Style panel integrated in App.tsx
- [ ] Theme toggle in header
- [ ] Format painter in toolbar
- [ ] Format painter click detection wired in Editor.tsx
- [ ] File operations load/save style metadata (including layout)
- [ ] Style changes mark document dirty
- [ ] Human verification passes all 9 tests
</success_criteria>

<deferred>
**CANV-04: Per-section backgrounds** - Deferred to Phase 4
- Requires TipTap custom node extension to track section boundaries
- Requires per-block metadata storage
- Too complex for this phase, will be addressed in content block phase
</deferred>

<output>
After completion, create `.planning/phases/03-style-system/03-04-SUMMARY.md`
</output>
