---
phase: 03-style-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/stores/styleStore.ts
  - src/stores/index.ts
  - src/lib/serqFormat.ts
  - src/lib/preferencesStore.ts
autonomous: true

must_haves:
  truths:
    - "Style state persists in Zustand store"
    - "Style changes mark document dirty"
    - "Document style saves to .serq.html metadata"
    - "Document style loads from .serq.html metadata"
    - "User defaults persist across app restarts"
    - "Layout presets are tracked and applied like other preset types"
    - "Master themes can be applied as single action"
  artifacts:
    - path: "src/stores/styleStore.ts"
      provides: "Style state management (current presets, format painter state, master themes)"
      exports: ["useStyleStore"]
    - path: "src/lib/serqFormat.ts"
      provides: "Updated serialization with style metadata"
      contains: "currentTypography"
  key_links:
    - from: "src/stores/styleStore.ts"
      to: "src/lib/presets.ts"
      via: "applyPreset calls"
      pattern: "applyTypographyPreset|applyColorPreset|applyCanvasPreset|applyLayoutPreset|applyMasterTheme"
    - from: "src/lib/serqFormat.ts"
      to: "src/stores/styleStore.ts"
      via: "reads current style for serialization"
      pattern: "useStyleStore"
---

<objective>
Create the Zustand style store and wire document style persistence.

Purpose: Central state management for all style-related state (current presets including layout, format painter mode, recent presets, master themes). Document styles persist in the .serq.html file metadata, and user defaults persist in the preferences store.

Output: Working style store, document metadata includes style info, styles load/save correctly
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-style-system/03-01-SUMMARY.md
@src/stores/editorStore.ts
@src/lib/serqFormat.ts
@src/lib/preferencesStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Style Store (Zustand)</name>
  <files>src/stores/styleStore.ts, src/stores/index.ts</files>
  <action>
Create a Zustand store for style state management.

```typescript
interface StyleState {
  // Current active presets
  currentTypography: string  // preset ID, e.g., 'classic-serif'
  currentColor: string       // preset ID
  currentCanvas: string      // preset ID
  currentLayout: string      // preset ID (NEW - for STYLE-03)
  currentMasterTheme: string | null  // master theme ID if using one, null if custom mix
  themeMode: 'light' | 'dark' | 'system'

  // Recently used (for quick access in UI)
  recentTypography: string[]  // max 5
  recentColors: string[]      // max 5
  recentCanvas: string[]      // max 5
  recentLayout: string[]      // max 5 (NEW)
  recentMasterThemes: string[] // max 5 (NEW)

  // Format painter state
  formatPainter: {
    active: boolean
    mode: 'toggle' | 'hold'
    storedFormat: StoredFormat | null
  }

  // Custom saved styles (user-created combinations)
  customStyles: CustomStyle[]

  // Actions
  setTypography: (presetId: string) => void
  setColor: (presetId: string) => void
  setCanvas: (presetId: string) => void
  setLayout: (presetId: string) => void  // NEW
  setMasterTheme: (themeId: string) => void  // NEW - applies typography + color + canvas + layout together
  setThemeMode: (mode: 'light' | 'dark' | 'system') => void

  // Format painter actions
  captureFormat: (editor: Editor) => void
  applyFormat: (editor: Editor) => void
  toggleFormatPainter: () => void
  deactivateFormatPainter: () => void

  // Custom style actions
  saveCustomStyle: (name: string) => void
  deleteCustomStyle: (id: string) => void
  renameCustomStyle: (id: string, newName: string) => void

  // Bulk operations
  applyAllPresets: () => void  // Apply current typography + color + canvas + layout
  resetToDefaults: () => void
  loadFromDocument: (metadata: SerqMetadata) => void
  getStyleMetadata: () => StyleMetadata
}
```

**Key behaviors:**
1. `set*` actions call the corresponding `apply*` function from presets.ts AND update store state
2. `set*` actions also update `recent*` arrays (prepend, dedupe, limit to 5)
3. `setMasterTheme(themeId)` applies all four presets from the theme AND sets currentMasterTheme
4. Individual `setTypography/setColor/setCanvas/setLayout` clears currentMasterTheme (now custom)
5. `applyAllPresets()` called after loading document or changing presets
6. `loadFromDocument()` reads presets from SerqMetadata and applies them
7. `getStyleMetadata()` returns current presets for document serialization

**Format Painter StoredFormat interface:**
```typescript
interface StoredFormat {
  marks: Array<{ type: string; attrs: Record<string, unknown> }>
  textAlign: string
}
```

Export from `src/stores/index.ts`.
  </action>
  <verify>Import store in console, call `setTypography('modern-sans')`, verify CSS variables update AND store state updates.</verify>
  <done>Style store manages current presets (including layout), recents, master themes, format painter state, and custom styles. Actions update both CSS variables and store state.</done>
</task>

<task type="auto">
  <name>Task 2: Document Style Persistence</name>
  <files>src/lib/serqFormat.ts</files>
  <action>
Update SerqMetadata interface and serialization to include document styles.

**Extend SerqMetadata:**
```typescript
export interface SerqMetadata {
  version: string
  created: string
  modified: string
  wordCount: number
  presets?: {
    typography?: string   // preset ID
    colors?: string       // preset ID
    canvas?: string       // preset ID
    layout?: string       // preset ID (NEW)
    masterTheme?: string | null  // master theme ID if using one (NEW)
    themeMode?: 'light' | 'dark' | 'system'
  }
  // Note: presets field already exists but may be undefined on old docs
}
```

**Update serializeSerqDocument():**
- Accept optional `styleMetadata` parameter (or get from styleStore)
- Write presets to metadata JSON

```typescript
export function serializeSerqDocument(
  html: string,
  documentMeta: { name: string; path?: string | null },
  styleMetadata?: { typography: string; colors: string; canvas: string; layout: string; masterTheme: string | null; themeMode: string }
): string
```

**Update parseSerqDocument():**
- Return presets from metadata (may be undefined for legacy docs)
- Caller (useFileOperations) will use this to call `styleStore.loadFromDocument()`

**Update updateSerqDocument():**
- Preserve existing style metadata OR accept new style metadata
- Style changes mark document dirty, so updated styles get saved

**Legacy document handling:**
- If `metadata.presets` is undefined, return undefined (caller applies user default)
- Never crash on missing presets
  </action>
  <verify>Create a test .serq.html manually with presets in metadata. Parse it and verify presets object is returned correctly.</verify>
  <done>SerqMetadata includes presets (including layout and masterTheme), serialization writes presets, parsing reads presets (with undefined fallback for legacy)</done>
</task>

<task type="auto">
  <name>Task 3: User Defaults Persistence</name>
  <files>src/lib/preferencesStore.ts</files>
  <action>
Extend the preferences store to persist user's default style and theme preference.

**Add to preferences:**
```typescript
interface Preferences {
  workingFolder: string | null
  recentFiles: RecentFile[]
  // NEW: Style defaults
  defaultTypography: string      // 'serq-default' initially
  defaultColor: string           // 'default' initially
  defaultCanvas: string          // 'white' initially
  defaultLayout: string          // 'default' initially (NEW)
  defaultMasterTheme: string | null  // null initially (NEW)
  themeMode: 'light' | 'dark' | 'system'  // 'system' initially
  recentTypography: string[]     // Persisted across sessions
  recentColors: string[]
  recentCanvas: string[]
  recentLayout: string[]         // NEW
  recentMasterThemes: string[]   // NEW
  customStyles: CustomStyle[]    // User's saved style combinations
}
```

**New functions:**
```typescript
export async function getStyleDefaults(): Promise<StyleDefaults>
export async function setStyleDefaults(defaults: Partial<StyleDefaults>): Promise<void>
export async function getCustomStyles(): Promise<CustomStyle[]>
export async function saveCustomStyles(styles: CustomStyle[]): Promise<void>
```

**Initialization:**
- On app start, load style defaults and apply them (for new documents)
- When user clicks "Set as Default" in style panel, call `setStyleDefaults()`
- Custom styles sync to preferences on every change

**Key: Recents vs Defaults**
- `recent*` arrays: Last 5 used presets, quick access
- `default*`: What new documents get, explicitly set by user
  </action>
  <verify>Set defaults via function call, restart app (or clear React state), verify defaults persist in preferences.json.</verify>
  <done>Preferences store persists style defaults (including layout), theme mode, recents, master themes, and custom styles across app restarts</done>
</task>

</tasks>

<verification>
1. Style changes update Zustand store state (check React DevTools or console)
2. Saving a document includes presets in the metadata JSON (inspect .serq.html file)
3. Opening a document with presets applies those presets (visual verification)
4. Opening a legacy document (no presets) uses user defaults (verify in console)
5. Restarting app preserves theme mode and style defaults
6. Layout preset changes are tracked and persisted like other preset types
7. Master theme application works (applies all four presets at once)
</verification>

<success_criteria>
- [ ] styleStore exports from stores/index.ts
- [ ] setTypography/setColor/setCanvas/setLayout update both CSS variables AND store state
- [ ] setMasterTheme applies all four presets at once
- [ ] serializeSerqDocument includes presets (including layout and masterTheme) in output
- [ ] parseSerqDocument returns presets (or undefined)
- [ ] preferencesStore has style defaults including layout
- [ ] Style changes mark document dirty (editorStore.markDirty called)
</success_criteria>

<output>
After completion, create `.planning/phases/03-style-system/03-02-SUMMARY.md`
</output>
