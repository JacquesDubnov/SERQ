---
phase: 08-document-output-and-pagination
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/docx-converter.ts
  - src/lib/export-handlers.ts
  - src/components/ExportMenu/ExportMenu.tsx
autonomous: true

must_haves:
  truths:
    - "User can export document to Word .docx format"
    - "Word export preserves headings, paragraphs, lists, bold, italic, and tables"
    - "Word file opens correctly in Microsoft Word and Google Docs"
  artifacts:
    - path: "src/lib/docx-converter.ts"
      provides: "TipTap JSON to docx.js document conversion"
      exports: ["convertTipTapToDocx"]
    - path: "src/lib/export-handlers.ts"
      provides: "exportToWord function"
      exports: ["exportToWord"]
    - path: "src/components/ExportMenu/ExportMenu.tsx"
      provides: "Word export option in menu"
      contains: "Word"
  key_links:
    - from: "src/lib/export-handlers.ts"
      to: "src/lib/docx-converter.ts"
      via: "import convertTipTapToDocx"
      pattern: "convertTipTapToDocx"
    - from: "src/components/ExportMenu/ExportMenu.tsx"
      to: "src/lib/export-handlers.ts"
      via: "import exportToWord"
      pattern: "exportToWord"
---

<objective>
Add Word .docx export capability using the docx npm package.

Purpose: Users need to share documents with Microsoft Word users. The docx package is the standard solution for programmatic Word document generation, used by 365+ projects. SERQ already has mammoth.js for import, so docx.js pairs naturally.

Output: New exportToWord function, TipTap-to-docx converter, Word option in ExportMenu.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-document-output-and-pagination/08-RESEARCH.md
@src/lib/export-handlers.ts
@src/components/ExportMenu/ExportMenu.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install docx and create TipTap-to-docx converter</name>
  <files>package.json, src/lib/docx-converter.ts</files>
  <action>
1. Install docx package:
```bash
cd /Users/jacquesdubnov/Coding/serq && npm install docx
```

2. Create src/lib/docx-converter.ts with:

```typescript
/**
 * TipTap JSON to docx.js Document Converter
 * Converts TipTap editor content to Word document format
 */
import {
  Document,
  Paragraph,
  TextRun,
  HeadingLevel,
  Table,
  TableRow,
  TableCell,
  WidthType,
  AlignmentType,
  BorderStyle,
  ImageRun,
} from 'docx'

// TipTap JSON types
interface TipTapNode {
  type?: string
  content?: TipTapNode[]
  attrs?: Record<string, unknown>
  marks?: TipTapMark[]
  text?: string
}

interface TipTapMark {
  type: string
  attrs?: Record<string, unknown>
}

/**
 * Convert TipTap JSON document to docx.js Document
 */
export function convertTipTapToDocx(json: TipTapNode): Document {
  const children = (json.content ?? []).flatMap(convertNodeToDocx)

  return new Document({
    sections: [{
      properties: {},
      children: children.flat(),
    }],
  })
}

/**
 * Convert a single TipTap node to docx Paragraph(s) or Table
 */
function convertNodeToDocx(node: TipTapNode): (Paragraph | Table)[] {
  switch (node.type) {
    case 'heading':
      return [new Paragraph({
        heading: getHeadingLevel(node.attrs?.level as number),
        children: convertInlineContent(node.content),
      })]

    case 'paragraph':
      return [new Paragraph({
        children: convertInlineContent(node.content),
        alignment: getAlignment(node.attrs?.textAlign as string),
      })]

    case 'bulletList':
      return (node.content ?? []).flatMap((li, index) =>
        convertListItem(li, 'bullet', index)
      )

    case 'orderedList':
      return (node.content ?? []).flatMap((li, index) =>
        convertListItem(li, 'number', index)
      )

    case 'blockquote':
      return (node.content ?? []).map(child => new Paragraph({
        children: convertInlineContent(child.content),
        indent: { left: 720 }, // 0.5 inch indent
        border: {
          left: { style: BorderStyle.SINGLE, size: 12, color: 'CCCCCC' },
        },
      }))

    case 'codeBlock':
      return [new Paragraph({
        children: [new TextRun({
          text: (node.content ?? []).map(n => n.text ?? '').join(''),
          font: 'Courier New',
          size: 20, // 10pt
        })],
        shading: { fill: 'F5F5F5' },
      })]

    case 'horizontalRule':
      return [new Paragraph({
        border: { bottom: { style: BorderStyle.SINGLE, size: 6, color: 'CCCCCC' } },
      })]

    case 'table':
      return [convertTable(node)]

    case 'image':
      return convertImage(node)

    case 'callout':
      // Convert callout as indented paragraphs with left border
      return (node.content ?? []).map(child => new Paragraph({
        children: convertInlineContent(child.content),
        indent: { left: 360 },
        border: {
          left: { style: BorderStyle.SINGLE, size: 24, color: getCalloutColor(node.attrs?.color as string) },
        },
        shading: { fill: getCalloutBgColor(node.attrs?.color as string) },
      }))

    default:
      // Try to extract any text content from unknown nodes
      if (node.content) {
        return node.content.flatMap(convertNodeToDocx)
      }
      return []
  }
}

/**
 * Convert inline content (text with marks) to TextRun array
 */
function convertInlineContent(content?: TipTapNode[]): TextRun[] {
  if (!content) return []

  return content.map(node => {
    if (node.type !== 'text' || !node.text) {
      return new TextRun({ text: '' })
    }

    const marks = node.marks ?? []

    return new TextRun({
      text: node.text,
      bold: marks.some(m => m.type === 'bold'),
      italics: marks.some(m => m.type === 'italic'),
      underline: marks.some(m => m.type === 'underline') ? {} : undefined,
      strike: marks.some(m => m.type === 'strike'),
      highlight: getHighlightColor(marks),
      font: getFontFamily(marks),
      size: getFontSize(marks),
    })
  })
}

/**
 * Convert list item to Paragraph with bullet/number
 */
function convertListItem(
  li: TipTapNode,
  type: 'bullet' | 'number',
  index: number
): Paragraph[] {
  const content = li.content ?? []

  return content.map((child, childIndex) => {
    // Only first paragraph gets the bullet/number
    if (child.type === 'paragraph' && childIndex === 0) {
      return new Paragraph({
        children: convertInlineContent(child.content),
        bullet: type === 'bullet' ? { level: 0 } : undefined,
        numbering: type === 'number' ? { reference: 'default-numbering', level: 0 } : undefined,
      })
    }
    // Nested content
    return new Paragraph({
      children: convertInlineContent(child.content),
      indent: { left: 720 },
    })
  })
}

/**
 * Convert TipTap table to docx Table
 */
function convertTable(node: TipTapNode): Table {
  const rows = (node.content ?? []).map((row, rowIndex) => {
    const cells = (row.content ?? []).map(cell => {
      const isHeader = cell.type === 'tableHeader'
      const content = (cell.content ?? []).flatMap(child =>
        convertInlineContent(child.content)
      )

      return new TableCell({
        children: [new Paragraph({ children: content })],
        shading: isHeader ? { fill: 'F0F0F0' } : undefined,
        width: { size: 100 / (row.content?.length ?? 1), type: WidthType.PERCENTAGE },
      })
    })

    return new TableRow({ children: cells })
  })

  return new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
  })
}

/**
 * Convert image node to Paragraph with ImageRun
 * Note: Images must be converted from base64 to Uint8Array
 */
function convertImage(node: TipTapNode): Paragraph[] {
  const src = node.attrs?.src as string
  if (!src || !src.startsWith('data:image')) {
    return [] // Skip non-base64 images for now
  }

  try {
    // Extract base64 data and convert to Uint8Array
    const base64Data = src.split(',')[1]
    const binaryString = atob(base64Data)
    const bytes = new Uint8Array(binaryString.length)
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }

    // Get dimensions (default to reasonable size if not specified)
    const width = (node.attrs?.width as number) ?? 400
    const height = (node.attrs?.height as number) ?? 300

    return [new Paragraph({
      children: [new ImageRun({
        data: bytes,
        transformation: { width, height },
        type: src.includes('png') ? 'png' : 'jpg',
      })],
    })]
  } catch (e) {
    console.warn('[Word Export] Failed to convert image:', e)
    return [new Paragraph({
      children: [new TextRun({ text: '[Image could not be exported]', italics: true })],
    })]
  }
}

// Helper functions
function getHeadingLevel(level?: number): HeadingLevel {
  switch (level) {
    case 1: return HeadingLevel.HEADING_1
    case 2: return HeadingLevel.HEADING_2
    case 3: return HeadingLevel.HEADING_3
    case 4: return HeadingLevel.HEADING_4
    case 5: return HeadingLevel.HEADING_5
    case 6: return HeadingLevel.HEADING_6
    default: return HeadingLevel.HEADING_1
  }
}

function getAlignment(align?: string): AlignmentType | undefined {
  switch (align) {
    case 'center': return AlignmentType.CENTER
    case 'right': return AlignmentType.RIGHT
    case 'justify': return AlignmentType.JUSTIFIED
    default: return undefined
  }
}

function getHighlightColor(marks: TipTapMark[]): string | undefined {
  const highlight = marks.find(m => m.type === 'highlight')
  if (!highlight) return undefined
  const color = highlight.attrs?.color as string
  // docx uses specific highlight color names
  return color === 'yellow' ? 'yellow' : undefined
}

function getFontFamily(marks: TipTapMark[]): string | undefined {
  const textStyle = marks.find(m => m.type === 'textStyle')
  return textStyle?.attrs?.fontFamily as string | undefined
}

function getFontSize(marks: TipTapMark[]): number | undefined {
  const textStyle = marks.find(m => m.type === 'textStyle')
  const size = textStyle?.attrs?.fontSize as string | undefined
  if (!size) return undefined
  // Convert CSS size to half-points (docx uses half-points)
  const match = size.match(/(\d+)/)
  return match ? parseInt(match[1]) * 2 : undefined
}

function getCalloutColor(color?: string): string {
  const colors: Record<string, string> = {
    blue: '0969DA',
    green: '1A7F37',
    yellow: '9A6700',
    orange: 'BC4C00',
    red: 'CF222E',
    purple: '8250DF',
    pink: 'BF3989',
    gray: '57606A',
  }
  return colors[color ?? 'blue'] ?? '0969DA'
}

function getCalloutBgColor(color?: string): string {
  const colors: Record<string, string> = {
    blue: 'E7F3FF',
    green: 'DAFBE1',
    yellow: 'FFF8C5',
    orange: 'FFF1E5',
    red: 'FFEBE9',
    purple: 'FBEFFF',
    pink: 'FFEFF7',
    gray: 'F6F8FA',
  }
  return colors[color ?? 'blue'] ?? 'E7F3FF'
}
```
  </action>
  <verify>
1. `npm ls docx` shows docx installed
2. `grep -c "convertTipTapToDocx" src/lib/docx-converter.ts` returns 1
3. TypeScript compiles: `npx tsc --noEmit src/lib/docx-converter.ts` (may have some warnings but no errors)
  </verify>
  <done>docx package installed, TipTap-to-docx converter created with support for all major node types.</done>
</task>

<task type="auto">
  <name>Task 2: Add exportToWord function and update ExportMenu</name>
  <files>src/lib/export-handlers.ts, src/components/ExportMenu/ExportMenu.tsx</files>
  <action>
1. In src/lib/export-handlers.ts, add import and export function:

Add to imports at top:
```typescript
import { Packer } from 'docx'
import { convertTipTapToDocx } from './docx-converter'
```

Add new export function (after exportToEPUB):
```typescript
/**
 * Export to Word .docx format
 * Uses docx.js to create a proper Word document
 */
export async function exportToWord(
  editor: Editor,
  documentName: string
): Promise<boolean> {
  console.log('[Word Export] Starting export for:', documentName)

  try {
    // Get TipTap JSON content
    const json = editor.getJSON()
    console.log('[Word Export] Got JSON content')

    // Convert to docx Document
    const doc = convertTipTapToDocx(json)
    console.log('[Word Export] Converted to docx Document')

    // Generate the .docx file as ArrayBuffer
    const buffer = await Packer.toBuffer(doc)
    console.log('[Word Export] Generated buffer, size:', buffer.byteLength)

    // Prompt for save location
    const defaultName = documentName.replace(/\.(serq\.html|html)$/i, '') + '.docx'
    const filePath = await save({
      defaultPath: defaultName,
      filters: [{ name: 'Word Document', extensions: ['docx'] }],
    })

    if (filePath) {
      await writeFile(filePath, new Uint8Array(buffer))
      console.log('[Word Export] File saved to:', filePath)
      return true
    }

    return false
  } catch (error) {
    console.error('[Word Export] Failed with error:', error)
    const errorMessage = error instanceof Error ? error.message : String(error)
    alert(`Word export failed: ${errorMessage}`)
    return false
  }
}
```

2. In src/components/ExportMenu/ExportMenu.tsx:

Update import:
```typescript
import { exportToHTML, exportToMarkdown, exportToPDF, exportToWord } from '../../lib/export-handlers'
```

Update ExportFormat type:
```typescript
type ExportFormat = 'html' | 'markdown' | 'pdf' | 'word'
```

Add Word option to EXPORT_OPTIONS array (add after 'pdf' entry):
```typescript
{ id: 'word', name: 'Word (.docx)', description: 'Microsoft Word document format' },
```

Add case in handleExport switch:
```typescript
case 'word':
  await exportToWord(editor, documentName)
  break
```
  </action>
  <verify>
1. `npm run build` completes without errors
2. `grep -c "exportToWord" src/lib/export-handlers.ts` returns 1 (definition) + 1 (export if separate)
3. `grep -c "word" src/components/ExportMenu/ExportMenu.tsx` returns at least 3 matches
  </verify>
  <done>Word export integrated into export system with menu option.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `ls src/lib/docx-converter.ts` confirms file exists
3. `grep "exportToWord" src/lib/export-handlers.ts` shows function exists
4. `grep "word" src/components/ExportMenu/ExportMenu.tsx` shows menu option
5. Manual test: Run app, create document with heading, paragraph, list, and table. Export to Word. Open in Word or Google Docs - content should be preserved.
</verification>

<success_criteria>
- docx package installed
- convertTipTapToDocx handles: headings, paragraphs, lists (bullet/ordered), blockquotes, code blocks, tables, images, callouts
- exportToWord function in export-handlers.ts
- "Word (.docx)" option in ExportMenu
- Exported .docx files open correctly in Microsoft Word/Google Docs
</success_criteria>

<output>
After completion, create `.planning/phases/08-document-output-and-pagination/08-02-SUMMARY.md`
</output>
