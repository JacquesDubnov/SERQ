---
phase: 07-layout-and-numbering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/extensions/ResizableImage/ResizableImage.ts
  - src/extensions/ResizableImage/ImageView.tsx
  - src/extensions/Callout/Callout.ts
  - src/extensions/Callout/CalloutView.tsx
  - src/styles/float.css
  - src/components/Editor/BlockContextMenu.tsx
  - src/components/Editor/EditorCore.tsx
autonomous: true

must_haves:
  truths:
    - "User can float images left, right, or center-wrap"
    - "User can float callouts with same options"
    - "Text wraps around floated elements"
    - "Headings automatically clear floats"
  artifacts:
    - path: "src/extensions/ResizableImage/ResizableImage.ts"
      provides: "Image node with float attribute"
      contains: "float:"
    - path: "src/extensions/Callout/Callout.ts"
      provides: "Callout node with float attribute"
      contains: "float:"
    - path: "src/styles/float.css"
      provides: "Float CSS classes"
      contains: ".block-float-left"
    - path: "src/components/Editor/BlockContextMenu.tsx"
      provides: "Context menu for float options"
      exports: ["BlockContextMenu"]
  key_links:
    - from: "src/extensions/ResizableImage/ImageView.tsx"
      to: "float.css"
      via: "className with float value"
      pattern: "block-float-"
    - from: "src/components/Editor/BlockContextMenu.tsx"
      to: "updateAttributes"
      via: "setBlockFloat callback"
      pattern: "updateAttributes.*float"
---

<objective>
Add text wrapping capability to block elements via float attributes and context menu controls.

Purpose: Enable magazine-style layouts where images and callouts can be positioned left/right with text flowing around them.

Output: Float controls in context menu, working text wrap for images and callouts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-layout-and-numbering/07-CONTEXT.md
@src/extensions/ResizableImage/ResizableImage.ts
@src/extensions/ResizableImage/ImageView.tsx
@src/extensions/Callout/Callout.ts
@src/extensions/Callout/CalloutView.tsx
@src/components/Editor/SelectionContextMenu.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Float Attributes to Extensions</name>
  <files>
    src/extensions/ResizableImage/ResizableImage.ts
    src/extensions/Callout/Callout.ts
  </files>
  <action>
Extend both ResizableImage and Callout with float attribute:

**ResizableImage.ts - add to addAttributes():**
```typescript
addAttributes() {
  return {
    src: { default: null },
    alt: { default: null },
    title: { default: null },
    width: { default: null },
    height: { default: null },
    alignment: { default: 'center' },
    // NEW: Float positioning
    float: {
      default: 'none',
      parseHTML: element => element.getAttribute('data-float') || 'none',
      renderHTML: attributes => ({
        'data-float': attributes.float,
      }),
    },
  }
}
```

**Callout.ts - add to addAttributes():**
```typescript
addAttributes() {
  return {
    color: { ... },
    icon: { ... },
    collapsed: { ... },
    collapsible: { ... },
    borderStyle: { ... },
    // NEW: Float positioning
    float: {
      default: 'none',
      parseHTML: element => element.getAttribute('data-float') || 'none',
      renderHTML: attributes => ({
        'data-float': attributes.float,
      }),
    },
  }
}
```

Also add commands to both extensions:
```typescript
addCommands() {
  return {
    // ... existing commands
    setBlockFloat: (position: 'none' | 'left' | 'right' | 'center-wrap') => ({ commands }) => {
      return commands.updateAttributes('image', { float: position })
    },
  }
}
```

IMPORTANT: Keep all existing attributes and commands. Only ADD the float attribute.
  </action>
  <verify>
TypeScript compiles: `cd /Users/jacquesdubnov/Coding/serq && npm run build 2>&1 | head -30`
  </verify>
  <done>Float attribute added to ResizableImage and Callout extensions</done>
</task>

<task type="auto">
  <name>Task 2: Create Float CSS and Update Views</name>
  <files>
    src/styles/float.css
    src/styles/editor.css
    src/extensions/ResizableImage/ImageView.tsx
    src/extensions/Callout/CalloutView.tsx
  </files>
  <action>
Create float CSS and apply in NodeViews:

**float.css:**
```css
/* Block Float Positioning */
.block-float-left {
  float: left;
  margin-right: 1.5rem;
  margin-bottom: 0.75rem;
  max-width: 50%;
}

.block-float-right {
  float: right;
  margin-left: 1.5rem;
  margin-bottom: 0.75rem;
  max-width: 50%;
}

.block-float-center-wrap {
  /* Center with wrap both sides - uses margin auto + shape-outside */
  display: block;
  margin: 0 auto 0.75rem auto;
  max-width: 50%;
  shape-outside: margin-box;
}

.block-float-none {
  float: none;
  margin-left: auto;
  margin-right: auto;
}

/* Clear Break */
.clear-float {
  clear: both;
}

/* Headings auto-clear floats */
.ProseMirror h1,
.ProseMirror h2,
.ProseMirror h3,
.ProseMirror h4,
.ProseMirror h5,
.ProseMirror h6 {
  clear: both;
}

/* Prevent float collapse in paragraphs */
.ProseMirror p::after {
  content: '';
  display: table;
  clear: both;
}
```

**Update editor.css:**
Add import at top:
```css
@import './float.css';
```

**Update ImageView.tsx:**
Apply float class based on node attribute:
```tsx
// In the NodeViewWrapper or container div:
<NodeViewWrapper
  className={`resizable-image-wrapper block-float-${node.attrs.float || 'none'}`}
  // ... rest of props
>
```

**Update CalloutView.tsx:**
Apply float class:
```tsx
<NodeViewWrapper
  className={`callout block-float-${node.attrs.float || 'none'}`}
  data-color={node.attrs.color}
  // ... rest of props
>
```

CRITICAL: Test that floated elements don't break paragraph layout.
  </action>
  <verify>
1. In browser dev tools, manually set `data-float="left"` on an image
2. Verify image floats left and text wraps on right
3. Add a heading - verify it clears the float
  </verify>
  <done>Float CSS classes created and applied to ImageView and CalloutView</done>
</task>

<task type="auto">
  <name>Task 3: Create Block Context Menu for Float Controls</name>
  <files>
    src/components/Editor/BlockContextMenu.tsx
    src/components/Editor/EditorCore.tsx
    src/components/Editor/index.ts
  </files>
  <action>
Create a context menu for block elements (images, callouts) with float options:

**BlockContextMenu.tsx:**
```tsx
/**
 * Block Context Menu
 * Right-click menu for block elements (images, callouts) with float and positioning options
 */
import { useEffect, useState, useCallback } from 'react'
import type { Editor } from '@tiptap/core'

interface Position {
  x: number
  y: number
}

interface BlockContextMenuProps {
  editor: Editor | null
  interfaceColors: {
    bg: string
    bgSurface: string
    border: string
    textPrimary: string
    textSecondary: string
  }
}

export function BlockContextMenu({ editor, interfaceColors }: BlockContextMenuProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState<Position>({ x: 0, y: 0 })
  const [targetNodeType, setTargetNodeType] = useState<string | null>(null)
  const [currentFloat, setCurrentFloat] = useState<string>('none')

  useEffect(() => {
    if (!editor) return

    const handleContextMenu = (e: MouseEvent) => {
      const target = e.target as HTMLElement

      // Check if right-clicking on image or callout
      const imageWrapper = target.closest('.resizable-image-wrapper')
      const calloutWrapper = target.closest('[data-callout]')

      if (imageWrapper || calloutWrapper) {
        e.preventDefault()
        e.stopPropagation()

        // Get node type and current float value
        const nodeType = imageWrapper ? 'image' : 'callout'
        const floatValue = (imageWrapper || calloutWrapper)?.getAttribute('data-float') || 'none'

        setTargetNodeType(nodeType)
        setCurrentFloat(floatValue)
        setPosition({ x: e.clientX, y: e.clientY })
        setIsOpen(true)
      }
    }

    const editorElement = editor.view.dom
    editorElement.addEventListener('contextmenu', handleContextMenu)

    return () => {
      editorElement.removeEventListener('contextmenu', handleContextMenu)
    }
  }, [editor])

  // Close handlers
  useEffect(() => {
    if (!isOpen) return

    const handleClick = () => setIsOpen(false)
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') setIsOpen(false)
    }

    document.addEventListener('click', handleClick)
    document.addEventListener('keydown', handleKeyDown)

    return () => {
      document.removeEventListener('click', handleClick)
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [isOpen])

  const handleSetFloat = useCallback((floatValue: string) => {
    if (!editor || !targetNodeType) return

    editor.chain().focus().updateAttributes(targetNodeType, { float: floatValue }).run()
    setIsOpen(false)
  }, [editor, targetNodeType])

  const handleInsertClearBreak = useCallback(() => {
    if (!editor) return

    // Insert a paragraph with clear class after current node
    editor.chain().focus().insertContent({
      type: 'paragraph',
      attrs: { class: 'clear-float' },
    }).run()
    setIsOpen(false)
  }, [editor])

  if (!isOpen) return null

  const menuStyle: React.CSSProperties = {
    position: 'fixed',
    left: position.x,
    top: position.y,
    backgroundColor: interfaceColors.bg,
    border: `1px solid ${interfaceColors.border}`,
    borderRadius: '8px',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.25)',
    padding: '4px',
    zIndex: 1000,
    minWidth: '160px',
  }

  const itemStyle: React.CSSProperties = {
    padding: '8px 12px',
    cursor: 'pointer',
    borderRadius: '4px',
    fontSize: '14px',
    color: interfaceColors.textPrimary,
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
  }

  const separatorStyle: React.CSSProperties = {
    height: '1px',
    backgroundColor: interfaceColors.border,
    margin: '4px 0',
  }

  const floatOptions = [
    { value: 'none', label: 'No Float', icon: '—' },
    { value: 'left', label: 'Float Left', icon: '←' },
    { value: 'right', label: 'Float Right', icon: '→' },
    { value: 'center-wrap', label: 'Center Wrap', icon: '↔' },
  ]

  return (
    <div style={menuStyle} onClick={(e) => e.stopPropagation()}>
      <div style={{ ...itemStyle, color: interfaceColors.textSecondary, fontSize: '12px', cursor: 'default' }}>
        Float Position
      </div>

      {floatOptions.map((option) => (
        <div
          key={option.value}
          style={{
            ...itemStyle,
            backgroundColor: currentFloat === option.value ? interfaceColors.bgSurface : 'transparent',
          }}
          onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
          onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = currentFloat === option.value ? interfaceColors.bgSurface : 'transparent')}
          onClick={() => handleSetFloat(option.value)}
        >
          <span style={{ width: '20px', textAlign: 'center' }}>{option.icon}</span>
          <span>{option.label}</span>
          {currentFloat === option.value && <span style={{ marginLeft: 'auto' }}>✓</span>}
        </div>
      ))}

      <div style={separatorStyle} />

      <div
        style={itemStyle}
        onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
        onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = 'transparent')}
        onClick={handleInsertClearBreak}
      >
        <span style={{ width: '20px', textAlign: 'center' }}>⏎</span>
        <span>Insert Clear Break</span>
      </div>
    </div>
  )
}
```

**Update EditorCore.tsx:**
Import and render BlockContextMenu alongside SelectionContextMenu:
```tsx
import { BlockContextMenu } from './BlockContextMenu'

// In JSX, after SelectionContextMenu:
<BlockContextMenu editor={editor} interfaceColors={interfaceColors} />
```

**Update index.ts:**
Add export:
```typescript
export { BlockContextMenu } from './BlockContextMenu'
```
  </action>
  <verify>
1. Run `npm run dev`
2. Insert an image via `/image`
3. Right-click on the image
4. Context menu appears with float options
5. Select "Float Left" - image floats left, text wraps
6. Right-click and select "No Float" - image returns to center
  </verify>
  <done>BlockContextMenu created with float options for images and callouts</done>
</task>

</tasks>

<verification>
1. Insert image, right-click, select "Float Left" - image floats left
2. Type text after image - text wraps around to the right
3. Insert heading - heading clears the float
4. Insert callout, right-click, select "Float Right" - callout floats right
5. "Insert Clear Break" forces content below floated element
6. Build passes: `npm run build`
</verification>

<success_criteria>
- Float attribute added to ResizableImage and Callout
- Float CSS classes apply correct positioning
- Block context menu appears on right-click
- Float options work: none, left, right, center-wrap
- Headings auto-clear floats
- Clear break option works
</success_criteria>

<output>
After completion, create `.planning/phases/07-layout-and-numbering/07-02-SUMMARY.md`
</output>
