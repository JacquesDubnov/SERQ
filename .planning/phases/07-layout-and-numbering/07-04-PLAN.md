---
phase: 07-layout-and-numbering
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/extensions/LineNumbers/LineNumbers.ts
  - src/extensions/LineNumbers/index.ts
  - src/styles/line-numbers.css
  - src/stores/editorStore.ts
  - src/components/Editor/EditorCore.tsx
  - src/components/Editor/CanvasContextMenu.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle line numbers via context menu"
    - "Line numbers appear in left gutter or margin"
    - "Line numbers update as document changes"
    - "Numbers only render for visible viewport (performance)"
  artifacts:
    - path: "src/extensions/LineNumbers/LineNumbers.ts"
      provides: "ProseMirror plugin for line numbering"
      exports: ["LineNumbers"]
    - path: "src/styles/line-numbers.css"
      provides: "Gutter and margin styling"
      contains: ".line-number-gutter"
    - path: "src/stores/editorStore.ts"
      provides: "Line number settings state"
      contains: "lineNumbers"
    - path: "src/components/Editor/CanvasContextMenu.tsx"
      provides: "Canvas right-click menu"
      exports: ["CanvasContextMenu"]
  key_links:
    - from: "src/extensions/LineNumbers/LineNumbers.ts"
      to: "editorStore"
      via: "reads line number settings"
      pattern: "useEditorStore"
    - from: "src/components/Editor/CanvasContextMenu.tsx"
      to: "toggle line numbers"
      via: "menu action"
      pattern: "setLineNumbers"
---

<objective>
Create line numbering system with gutter display and viewport optimization.

Purpose: Enable code-editor or legal-style line numbers for citation, reference, and professional document formatting.

Output: Toggleable line numbers in gutter or margin position, performance-optimized for long documents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-layout-and-numbering/07-CONTEXT.md
@src/stores/editorStore.ts
@src/components/Editor/EditorCore.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Line Number Settings to Store</name>
  <files>
    src/stores/editorStore.ts
  </files>
  <action>
Extend editorStore with line number settings:

**Add to EditorState interface:**
```typescript
interface EditorState {
  // ... existing fields

  // Line Numbers settings
  lineNumbers: {
    enabled: boolean
    position: 'gutter' | 'margin' // gutter = outside canvas, margin = inside canvas
    style: 'code' | 'legal' // code = every line, legal = every 5 lines
  }

  // Actions
  setLineNumbers: (settings: Partial<EditorState['lineNumbers']>) => void
  toggleLineNumbers: () => void
}
```

**Add to store implementation:**
```typescript
// Initial state
lineNumbers: {
  enabled: false,
  position: 'gutter',
  style: 'code',
},

// Actions
setLineNumbers: (settings) =>
  set((state) => ({
    lineNumbers: { ...state.lineNumbers, ...settings },
  })),

toggleLineNumbers: () =>
  set((state) => ({
    lineNumbers: { ...state.lineNumbers, enabled: !state.lineNumbers.enabled },
  })),
```

CRITICAL: Line numbers are document-wide settings, not per-block.
  </action>
  <verify>
TypeScript compiles: `npm run build 2>&1 | head -20`
  </verify>
  <done>Line number settings added to editorStore</done>
</task>

<task type="auto">
  <name>Task 2: Create LineNumbers Extension with Gutter Plugin</name>
  <files>
    src/extensions/LineNumbers/LineNumbers.ts
    src/extensions/LineNumbers/index.ts
    src/styles/line-numbers.css
  </files>
  <action>
Create the line numbers extension using ProseMirror plugin with gutter DOM:

**LineNumbers.ts:**
```typescript
import { Extension } from '@tiptap/core'
import { Plugin, PluginKey } from '@tiptap/pm/state'
import { Decoration, DecorationSet } from '@tiptap/pm/view'

export interface LineNumbersOptions {
  getSettings: () => {
    enabled: boolean
    position: 'gutter' | 'margin'
    style: 'code' | 'legal'
  }
}

export const lineNumbersPluginKey = new PluginKey('lineNumbers')

export const LineNumbers = Extension.create<LineNumbersOptions>({
  name: 'lineNumbers',

  addOptions() {
    return {
      getSettings: () => ({ enabled: false, position: 'gutter', style: 'code' }),
    }
  },

  addProseMirrorPlugins() {
    const getSettings = this.options.getSettings

    return [
      new Plugin({
        key: lineNumbersPluginKey,

        state: {
          init(_, state) {
            return { lineCount: 0 }
          },
          apply(tr, value, oldState, newState) {
            // Recalculate line count on doc change
            return { lineCount: countLines(newState.doc) }
          },
        },

        view(editorView) {
          // Create gutter container
          const gutter = document.createElement('div')
          gutter.className = 'line-number-gutter'

          // Get editor container and insert gutter
          const editorContainer = editorView.dom.parentElement
          if (editorContainer) {
            editorContainer.insertBefore(gutter, editorView.dom)
          }

          // Render function
          const render = () => {
            const settings = getSettings()

            if (!settings.enabled) {
              gutter.style.display = 'none'
              editorView.dom.classList.remove('with-line-numbers', 'line-numbers-gutter', 'line-numbers-margin')
              return
            }

            gutter.style.display = 'block'
            editorView.dom.classList.add('with-line-numbers')
            editorView.dom.classList.toggle('line-numbers-gutter', settings.position === 'gutter')
            editorView.dom.classList.toggle('line-numbers-margin', settings.position === 'margin')
            gutter.classList.toggle('position-gutter', settings.position === 'gutter')
            gutter.classList.toggle('position-margin', settings.position === 'margin')

            // Get visible range for viewport optimization
            const { from, to } = getVisibleRange(editorView)

            // Clear and rebuild gutter content
            gutter.innerHTML = ''

            // Calculate line positions
            const lines = getLinePositions(editorView.state.doc, from, to)

            lines.forEach((line, index) => {
              const lineNumber = line.lineNumber

              // For legal style, only show every 5th line
              if (settings.style === 'legal' && lineNumber % 5 !== 0) {
                return
              }

              const lineEl = document.createElement('div')
              lineEl.className = 'line-number'
              lineEl.textContent = String(lineNumber)

              // Position based on line's top coordinate
              const coords = editorView.coordsAtPos(line.from)
              const editorRect = editorView.dom.getBoundingClientRect()
              lineEl.style.top = `${coords.top - editorRect.top}px`

              gutter.appendChild(lineEl)
            })
          }

          // Initial render
          render()

          return {
            update(view) {
              render()
            },
            destroy() {
              gutter.remove()
            },
          }
        },
      }),
    ]
  },
})

// Helper: Count total lines in document
function countLines(doc: any): number {
  let count = 0
  doc.descendants((node: any) => {
    if (node.isBlock) count++
    return true
  })
  return count
}

// Helper: Get visible viewport range
function getVisibleRange(view: any): { from: number; to: number } {
  const dom = view.dom as HTMLElement
  const scrollParent = dom.closest('.canvas-container') || window

  const scrollTop = scrollParent === window
    ? window.scrollY
    : (scrollParent as HTMLElement).scrollTop

  const viewportHeight = scrollParent === window
    ? window.innerHeight
    : (scrollParent as HTMLElement).clientHeight

  const domRect = dom.getBoundingClientRect()

  // Find positions at top and bottom of viewport
  const topPos = view.posAtCoords({ left: domRect.left + 10, top: Math.max(0, scrollTop) })
  const bottomPos = view.posAtCoords({ left: domRect.left + 10, top: scrollTop + viewportHeight })

  return {
    from: topPos?.pos ?? 0,
    to: bottomPos?.pos ?? view.state.doc.content.size,
  }
}

// Helper: Get line positions within range
function getLinePositions(
  doc: any,
  from: number,
  to: number
): Array<{ lineNumber: number; from: number; to: number }> {
  const lines: Array<{ lineNumber: number; from: number; to: number }> = []
  let lineNumber = 0

  doc.descendants((node: any, pos: number) => {
    if (node.isBlock && !node.isTextblock) return true
    if (node.isTextblock) {
      lineNumber++
      // Only include if within visible range (with buffer)
      if (pos >= from - 500 && pos <= to + 500) {
        lines.push({ lineNumber, from: pos, to: pos + node.nodeSize })
      }
    }
    return true
  })

  return lines
}

export default LineNumbers
```

**index.ts:**
```typescript
export { LineNumbers, lineNumbersPluginKey } from './LineNumbers'
```

**line-numbers.css:**
```css
/* Line Number Gutter */
.line-number-gutter {
  position: absolute;
  left: 0;
  top: 0;
  width: 40px;
  height: 100%;
  pointer-events: none;
  user-select: none;
  font-family: var(--font-mono, 'SF Mono', 'Monaco', 'Menlo', monospace);
  font-size: 12px;
  color: var(--color-text-secondary, #9ca3af);
  line-height: inherit;
  z-index: 1;
}

.line-number-gutter.position-gutter {
  left: -50px;
}

.line-number-gutter.position-margin {
  left: 0;
  background: var(--color-bg-surface, #f9fafb);
  border-right: 1px solid var(--color-border, #e5e7eb);
}

.line-number {
  position: absolute;
  right: 8px;
  text-align: right;
  height: 1.6em; /* Match line-height */
}

/* Editor adjustments when line numbers are active */
.ProseMirror.with-line-numbers.line-numbers-margin {
  padding-left: 50px;
}

.ProseMirror.with-line-numbers.line-numbers-gutter {
  /* Gutter is outside, no padding needed */
}

/* Canvas container needs relative for gutter positioning */
.canvas-container {
  position: relative;
}
```

**Update editor.css:**
```css
@import './line-numbers.css';
```

CRITICAL: Use viewport optimization - only render visible line numbers.
CRITICAL: Position gutter absolutely relative to editor container.
CRITICAL: Use coordsAtPos for accurate line positioning.
  </action>
  <verify>
1. TypeScript compiles: `npm run build`
2. Add LineNumbers extension to editor with getSettings callback
3. Toggle line numbers via store action - gutter appears/disappears
  </verify>
  <done>LineNumbers extension created with gutter plugin and viewport optimization</done>
</task>

<task type="auto">
  <name>Task 3: Create Canvas Context Menu and Integration</name>
  <files>
    src/components/Editor/CanvasContextMenu.tsx
    src/components/Editor/EditorCore.tsx
    src/components/Editor/index.ts
  </files>
  <action>
Create context menu for canvas (empty space) with line number controls:

**CanvasContextMenu.tsx:**
```tsx
/**
 * Canvas Context Menu
 * Right-click menu on empty canvas space for document-wide settings
 */
import { useEffect, useState, useCallback } from 'react'
import type { Editor } from '@tiptap/core'
import { useEditorStore } from '../../stores/editorStore'

interface Position {
  x: number
  y: number
}

interface CanvasContextMenuProps {
  editor: Editor | null
  interfaceColors: {
    bg: string
    bgSurface: string
    border: string
    textPrimary: string
    textSecondary: string
  }
}

export function CanvasContextMenu({ editor, interfaceColors }: CanvasContextMenuProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [position, setPosition] = useState<Position>({ x: 0, y: 0 })

  const lineNumbers = useEditorStore((s) => s.lineNumbers)
  const setLineNumbers = useEditorStore((s) => s.setLineNumbers)
  const toggleLineNumbers = useEditorStore((s) => s.toggleLineNumbers)

  useEffect(() => {
    if (!editor) return

    const handleContextMenu = (e: MouseEvent) => {
      const target = e.target as HTMLElement

      // Only trigger on empty canvas area (the canvas-container, not content)
      const isCanvas = target.classList.contains('canvas-container') ||
                      target.closest('.canvas-container')?.querySelector('.ProseMirror') === e.target

      // Check if click is in empty space (below content)
      const proseMirror = target.closest('.ProseMirror')
      if (proseMirror) {
        const lastChild = proseMirror.lastElementChild
        if (lastChild) {
          const lastRect = lastChild.getBoundingClientRect()
          if (e.clientY <= lastRect.bottom) {
            // Clicked on content, not empty space
            return
          }
        }
      }

      // Show canvas menu if in empty area
      if (isCanvas || proseMirror) {
        e.preventDefault()
        setPosition({ x: e.clientX, y: e.clientY })
        setIsOpen(true)
      }
    }

    const editorContainer = editor.view.dom.parentElement
    if (editorContainer) {
      editorContainer.addEventListener('contextmenu', handleContextMenu)
    }

    return () => {
      if (editorContainer) {
        editorContainer.removeEventListener('contextmenu', handleContextMenu)
      }
    }
  }, [editor])

  // Close handlers
  useEffect(() => {
    if (!isOpen) return

    const handleClick = () => setIsOpen(false)
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') setIsOpen(false)
    }

    document.addEventListener('click', handleClick)
    document.addEventListener('keydown', handleKeyDown)

    return () => {
      document.removeEventListener('click', handleClick)
      document.removeEventListener('keydown', handleKeyDown)
    }
  }, [isOpen])

  const handleLineNumberToggle = useCallback(() => {
    toggleLineNumbers()
    setIsOpen(false)
  }, [toggleLineNumbers])

  const handleLineNumberPosition = useCallback((position: 'gutter' | 'margin') => {
    setLineNumbers({ position, enabled: true })
    setIsOpen(false)
  }, [setLineNumbers])

  const handleLineNumberStyle = useCallback((style: 'code' | 'legal') => {
    setLineNumbers({ style, enabled: true })
    setIsOpen(false)
  }, [setLineNumbers])

  if (!isOpen) return null

  const menuStyle: React.CSSProperties = {
    position: 'fixed',
    left: position.x,
    top: position.y,
    backgroundColor: interfaceColors.bg,
    border: `1px solid ${interfaceColors.border}`,
    borderRadius: '8px',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.25)',
    padding: '4px',
    zIndex: 1000,
    minWidth: '180px',
  }

  const itemStyle: React.CSSProperties = {
    padding: '8px 12px',
    cursor: 'pointer',
    borderRadius: '4px',
    fontSize: '14px',
    color: interfaceColors.textPrimary,
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
  }

  const subItemStyle: React.CSSProperties = {
    ...itemStyle,
    paddingLeft: '28px',
    fontSize: '13px',
  }

  const separatorStyle: React.CSSProperties = {
    height: '1px',
    backgroundColor: interfaceColors.border,
    margin: '4px 0',
  }

  const labelStyle: React.CSSProperties = {
    ...itemStyle,
    color: interfaceColors.textSecondary,
    fontSize: '12px',
    cursor: 'default',
  }

  return (
    <div style={menuStyle} onClick={(e) => e.stopPropagation()}>
      {/* Line Numbers Section */}
      <div style={labelStyle}>Line Numbers</div>

      <div
        style={{
          ...itemStyle,
          backgroundColor: lineNumbers.enabled ? interfaceColors.bgSurface : 'transparent',
        }}
        onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
        onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = lineNumbers.enabled ? interfaceColors.bgSurface : 'transparent')}
        onClick={handleLineNumberToggle}
      >
        <span style={{ width: '16px' }}>{lineNumbers.enabled ? '✓' : ''}</span>
        <span>Show Line Numbers</span>
      </div>

      {lineNumbers.enabled && (
        <>
          <div style={separatorStyle} />
          <div style={{ ...labelStyle, paddingLeft: '12px' }}>Position</div>

          <div
            style={{
              ...subItemStyle,
              backgroundColor: lineNumbers.position === 'gutter' ? interfaceColors.bgSurface : 'transparent',
            }}
            onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
            onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = lineNumbers.position === 'gutter' ? interfaceColors.bgSurface : 'transparent')}
            onClick={() => handleLineNumberPosition('gutter')}
          >
            <span style={{ width: '16px' }}>{lineNumbers.position === 'gutter' ? '•' : ''}</span>
            <span>Gutter (outside canvas)</span>
          </div>

          <div
            style={{
              ...subItemStyle,
              backgroundColor: lineNumbers.position === 'margin' ? interfaceColors.bgSurface : 'transparent',
            }}
            onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
            onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = lineNumbers.position === 'margin' ? interfaceColors.bgSurface : 'transparent')}
            onClick={() => handleLineNumberPosition('margin')}
          >
            <span style={{ width: '16px' }}>{lineNumbers.position === 'margin' ? '•' : ''}</span>
            <span>Margin (inside canvas)</span>
          </div>

          <div style={separatorStyle} />
          <div style={{ ...labelStyle, paddingLeft: '12px' }}>Style</div>

          <div
            style={{
              ...subItemStyle,
              backgroundColor: lineNumbers.style === 'code' ? interfaceColors.bgSurface : 'transparent',
            }}
            onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
            onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = lineNumbers.style === 'code' ? interfaceColors.bgSurface : 'transparent')}
            onClick={() => handleLineNumberStyle('code')}
          >
            <span style={{ width: '16px' }}>{lineNumbers.style === 'code' ? '•' : ''}</span>
            <span>Every line (1, 2, 3...)</span>
          </div>

          <div
            style={{
              ...subItemStyle,
              backgroundColor: lineNumbers.style === 'legal' ? interfaceColors.bgSurface : 'transparent',
            }}
            onMouseEnter={(e) => (e.currentTarget.style.backgroundColor = interfaceColors.bgSurface)}
            onMouseLeave={(e) => (e.currentTarget.style.backgroundColor = lineNumbers.style === 'legal' ? interfaceColors.bgSurface : 'transparent')}
            onClick={() => handleLineNumberStyle('legal')}
          >
            <span style={{ width: '16px' }}>{lineNumbers.style === 'legal' ? '•' : ''}</span>
            <span>Every 5th (5, 10, 15...)</span>
          </div>
        </>
      )}
    </div>
  )
}
```

**Update EditorCore.tsx:**
```typescript
import { CanvasContextMenu } from './CanvasContextMenu'
import { LineNumbers } from '../../extensions/LineNumbers'

// In extensions array:
LineNumbers.configure({
  getSettings: () => useEditorStore.getState().lineNumbers,
}),

// In JSX:
<CanvasContextMenu editor={editor} interfaceColors={interfaceColors} />
```

**Update index.ts:**
```typescript
export { CanvasContextMenu } from './CanvasContextMenu'
```

CRITICAL: Canvas context menu triggers on empty space below content.
CRITICAL: LineNumbers extension reads settings via getSettings callback.
  </action>
  <verify>
1. Run `npm run dev`
2. Right-click on empty canvas space (below text content)
3. "Line Numbers" menu appears
4. Toggle on - line numbers appear in gutter
5. Switch to "margin" position - numbers move inside canvas
6. Switch to "legal" style - only shows 5, 10, 15...
  </verify>
  <done>Canvas context menu with line number controls integrated</done>
</task>

</tasks>

<verification>
1. Right-click empty canvas - menu appears with Line Numbers section
2. Enable line numbers - numbers appear in left gutter
3. Switch position to "margin" - numbers move inside canvas with background
4. Switch style to "legal" - only every 5th line numbered
5. Add/remove text - line numbers update dynamically
6. Scroll long document - only visible lines have numbers rendered (check DOM)
7. Build passes: `npm run build`
</verification>

<success_criteria>
- Line number settings in editorStore
- LineNumbers extension with gutter plugin
- Viewport optimization (only visible lines rendered)
- Canvas context menu with position and style options
- Numbers accurate and update on doc changes
</success_criteria>

<output>
After completion, create `.planning/phases/07-layout-and-numbering/07-04-SUMMARY.md`
</output>
