---
phase: 06-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/commands/ai.rs
  - src-tauri/capabilities/default.json
  - src/lib/ai-keyring.ts
  - src/components/Settings/ApiKeySettings.tsx
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude API for AI text stylization"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "console.anthropic.com -> API Keys"
    dashboard_config: []

must_haves:
  truths:
    - "API key can be stored securely in macOS keychain"
    - "API key can be retrieved for use in API calls"
    - "User can enter/update API key via settings UI"
  artifacts:
    - path: "src-tauri/src/commands/ai.rs"
      provides: "Tauri commands for keyring operations"
      exports: ["set_api_key", "get_api_key", "has_api_key"]
    - path: "src/lib/ai-keyring.ts"
      provides: "Frontend wrapper for keyring commands"
      exports: ["saveApiKey", "getApiKey", "hasApiKey"]
    - path: "src/components/Settings/ApiKeySettings.tsx"
      provides: "Settings UI for API key management"
  key_links:
    - from: "src/components/Settings/ApiKeySettings.tsx"
      to: "src/lib/ai-keyring.ts"
      via: "imports and calls saveApiKey/hasApiKey"
      pattern: "saveApiKey|hasApiKey"
    - from: "src/lib/ai-keyring.ts"
      to: "src-tauri/src/commands/ai.rs"
      via: "invoke calls"
      pattern: "invoke.*set_api_key|get_api_key|has_api_key"
---

<objective>
Set up Rust backend foundation for Claude API integration with secure keyring-based API key storage.

Purpose: Claude API requires an API key. Storing it in localStorage or plain files is insecure. The macOS Keychain provides system-level encryption. This plan establishes the secure storage infrastructure and creates the settings UI for users to enter their key.

Output: Working API key storage system with Rust commands, frontend wrappers, and settings UI component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-ai-integration/06-RESEARCH.md

# Existing Tauri setup
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Rust dependencies and create command module structure</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/commands/mod.rs
    src-tauri/src/commands/ai.rs
    src-tauri/src/lib.rs
  </files>
  <action>
1. Add to src-tauri/Cargo.toml dependencies:
   ```toml
   reqwest = { version = "0.12", features = ["stream", "json"] }
   eventsource-stream = "0.2"
   futures = "0.3"
   tauri-plugin-keyring = "2"
   uuid = { version = "1", features = ["v4"] }
   ```

2. Create src-tauri/src/commands/ directory

3. Create src-tauri/src/commands/mod.rs:
   ```rust
   pub mod ai;
   pub use ai::*;
   ```

4. Create src-tauri/src/commands/ai.rs with keyring commands:
   - Use tauri_plugin_keyring::KeyringExt
   - Define constants: SERVICE = "com.serq.app", KEY_NAME = "anthropic-api-key"
   - Implement three commands:
     - `set_api_key(app: AppHandle, key: String) -> Result<(), String>`: Store key in keychain
     - `get_api_key(app: AppHandle) -> Result<Option<String>, String>`: Retrieve key (returns None if not set)
     - `has_api_key(app: AppHandle) -> Result<bool, String>`: Check if key exists without retrieving it
   - Handle keyring::Error::NoEntry gracefully (return None/false, not error)

5. Update src-tauri/src/lib.rs:
   - Add `mod commands;` at top
   - Add `.plugin(tauri_plugin_keyring::init())` to builder (BEFORE other plugins)
   - Add commands to invoke_handler: `tauri::generate_handler![commands::set_api_key, commands::get_api_key, commands::has_api_key, greet]`

Note: The keyring plugin must be registered before being used in commands.
  </action>
  <verify>
Run `cd /Users/jacquesdubnov/Coding/serq/src-tauri && cargo check` - should compile without errors
  </verify>
  <done>
Rust backend compiles with keyring plugin registered and three commands available: set_api_key, get_api_key, has_api_key
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Tauri capabilities for keyring access</name>
  <files>
    src-tauri/capabilities/default.json
  </files>
  <action>
1. Read the existing src-tauri/capabilities/default.json

2. Add keyring permissions to the permissions array:
   - "keyring:default" - enables keyring operations

The keyring plugin uses system keychain which doesn't require file path scoping like fs plugin.

Note: If capabilities file doesn't exist or has different structure, check Tauri 2 docs for correct format. The pattern is:
```json
{
  "permissions": [
    "existing-permission",
    "keyring:default"
  ]
}
```
  </action>
  <verify>
File exists and contains "keyring:default" permission
  </verify>
  <done>
Tauri capabilities include keyring permission for secure API key storage
  </done>
</task>

<task type="auto">
  <name>Task 3: Create frontend API key management utilities and settings UI</name>
  <files>
    src/lib/ai-keyring.ts
    src/components/Settings/ApiKeySettings.tsx
    src/components/Settings/index.ts
  </files>
  <action>
1. Create src/lib/ai-keyring.ts:
   ```typescript
   import { invoke } from '@tauri-apps/api/core';

   /**
    * Save API key to system keychain (macOS Keychain)
    * Key is encrypted at rest by the OS
    */
   export async function saveApiKey(key: string): Promise<void> {
     await invoke('set_api_key', { key });
   }

   /**
    * Retrieve API key from keychain
    * Returns null if no key is stored
    */
   export async function getApiKey(): Promise<string | null> {
     return invoke('get_api_key');
   }

   /**
    * Check if API key exists without retrieving it
    * Use this for UI state (show "configured" vs "not configured")
    */
   export async function hasApiKey(): Promise<boolean> {
     return invoke('has_api_key');
   }

   /**
    * Delete API key from keychain
    * (Sets empty string - keyring doesn't have delete, just overwrite)
    */
   export async function deleteApiKey(): Promise<void> {
     await invoke('set_api_key', { key: '' });
   }
   ```

2. Create src/components/Settings/ directory if it doesn't exist

3. Create src/components/Settings/ApiKeySettings.tsx:
   - Import: React useState/useEffect, saveApiKey/hasApiKey from ai-keyring
   - State: hasKey (boolean), inputValue (string), saving (boolean), showInput (boolean)
   - On mount: Call hasApiKey() to check if configured
   - UI structure:
     - If hasKey && !showInput: Show "API key configured" with edit button
     - If !hasKey || showInput: Show input field with save/cancel buttons
   - Input should be type="password" for security
   - On save: Call saveApiKey(inputValue), update hasKey state, clear input, hide input
   - Show toast or inline message on success
   - Style with Tailwind: card-like container, proper spacing

4. Create src/components/Settings/index.ts:
   ```typescript
   export { ApiKeySettings } from './ApiKeySettings';
   ```

Note: This component will be integrated into a settings modal/panel in a later plan. For now it's self-contained.
  </action>
  <verify>
- File src/lib/ai-keyring.ts exists with 4 exported functions
- File src/components/Settings/ApiKeySettings.tsx exists and exports component
- Run `npm run dev` and check no TypeScript errors
  </verify>
  <done>
Frontend has API key management: ai-keyring.ts provides invoke wrappers, ApiKeySettings.tsx provides UI for entering/updating API key
  </done>
</task>

</tasks>

<verification>
1. Rust compiles: `cd src-tauri && cargo check` passes
2. Frontend builds: `npm run build` passes without TS errors
3. Manual test (dev mode):
   - Import ApiKeySettings in App.tsx temporarily
   - Enter a test API key
   - Refresh page - should show "configured"
   - Check macOS Keychain Access app - "anthropic-api-key" should appear under "com.serq.app"
</verification>

<success_criteria>
- Rust backend has keyring plugin registered with set/get/has commands
- Frontend can invoke keyring commands without errors
- API key persists in macOS Keychain across app restarts
- Settings UI shows correct state (configured/not configured)
</success_criteria>

<output>
After completion, create `.planning/phases/06-ai-integration/06-01-SUMMARY.md`
</output>
