---
phase: 05-polish
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/components/VersionHistory/VersionHistoryPanel.tsx
  - src/components/VersionHistory/VersionList.tsx
  - src/components/VersionHistory/VersionPreview.tsx
  - src/hooks/useVersionHistory.ts
  - src/styles/version-history.css
autonomous: true

must_haves:
  truths:
    - "User can open version history panel to see all saved versions"
    - "User can preview any version before restoring"
    - "User can restore entire document from any version"
    - "User can name checkpoints on Cmd+S save"
  artifacts:
    - path: "src/components/VersionHistory/VersionHistoryPanel.tsx"
      provides: "Main version history panel component"
      min_lines: 100
    - path: "src/components/VersionHistory/VersionPreview.tsx"
      provides: "Read-only preview of selected version"
      min_lines: 30
    - path: "src/hooks/useVersionHistory.ts"
      provides: "Version history operations hook"
      exports: ["useVersionHistory"]
  key_links:
    - from: "src/hooks/useVersionHistory.ts"
      to: "src/lib/version-storage.ts"
      via: "version storage imports"
      pattern: "import.*getVersions.*from.*version-storage"
    - from: "src/components/VersionHistory/VersionHistoryPanel.tsx"
      to: "src/hooks/useVersionHistory.ts"
      via: "hook usage"
      pattern: "useVersionHistory"
---

<objective>
Create version history UI for browsing, previewing, and restoring document versions.

Purpose: Users need to recover from mistakes or compare past versions. Time Machine-style interface shows version timeline with preview before restore, giving users confidence in recovery operations.

Output:
- Version history panel with timeline view
- Version preview in read-only editor
- Restore functionality with undo safety
- Checkpoint naming on explicit save
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-polish/05-RESEARCH.md
@.planning/phases/05-polish/05-01-SUMMARY.md

# Existing patterns
@src/components/DocumentOutline/OutlinePanel.tsx
@src/stores/editorStore.ts
@src/lib/version-storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create version history hook</name>
  <files>
    src/hooks/useVersionHistory.ts
    src/hooks/index.ts
  </files>
  <action>
1. Create `src/hooks/useVersionHistory.ts`:

```typescript
/**
 * Version History Hook
 * Manages version history state and operations
 */
import { useState, useCallback, useEffect } from 'react';
import type { Editor } from '@tiptap/core';
import {
  getVersions,
  getVersionById,
  saveVersion,
  type Version,
} from '../lib/version-storage';
import { useEditorStore } from '../stores/editorStore';

interface UseVersionHistoryReturn {
  /** List of versions for current document */
  versions: Version[];
  /** Currently selected version for preview */
  selectedVersion: Version | null;
  /** Whether versions are loading */
  isLoading: boolean;
  /** Load versions for current document */
  loadVersions: () => Promise<void>;
  /** Select a version for preview */
  selectVersion: (versionId: number) => Promise<void>;
  /** Restore selected version to editor */
  restoreVersion: (editor: Editor) => Promise<boolean>;
  /** Create a named checkpoint from current content */
  createCheckpoint: (editor: Editor, name: string) => Promise<boolean>;
  /** Clear selection */
  clearSelection: () => void;
}

export function useVersionHistory(): UseVersionHistoryReturn {
  const [versions, setVersions] = useState<Version[]>([]);
  const [selectedVersion, setSelectedVersion] = useState<Version | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const documentPath = useEditorStore((state) => state.document.path);
  const markDirty = useEditorStore((state) => state.markDirty);

  // Load versions when document path changes
  const loadVersions = useCallback(async () => {
    if (!documentPath) {
      setVersions([]);
      return;
    }

    setIsLoading(true);
    try {
      const versionList = await getVersions(documentPath, 100);
      setVersions(versionList);
    } catch (err) {
      console.error('[VersionHistory] Failed to load versions:', err);
      setVersions([]);
    } finally {
      setIsLoading(false);
    }
  }, [documentPath]);

  // Auto-load versions when document path changes
  useEffect(() => {
    loadVersions();
  }, [loadVersions]);

  // Select a version for preview
  const selectVersion = useCallback(async (versionId: number) => {
    setIsLoading(true);
    try {
      const version = await getVersionById(versionId);
      setSelectedVersion(version);
    } catch (err) {
      console.error('[VersionHistory] Failed to load version:', err);
      setSelectedVersion(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Restore selected version to editor
  const restoreVersion = useCallback(
    async (editor: Editor): Promise<boolean> => {
      if (!selectedVersion || !documentPath) {
        return false;
      }

      try {
        // Parse version content
        const content = JSON.parse(selectedVersion.content);

        // Save current state as backup checkpoint before restore
        const currentJSON = editor.getJSON();
        const wordCount = editor.storage.characterCount?.words?.() ?? 0;
        const charCount = editor.storage.characterCount?.characters?.() ?? 0;

        await saveVersion(
          documentPath,
          currentJSON,
          wordCount,
          charCount,
          true, // Named checkpoint
          `Before restore to version from ${new Date(selectedVersion.timestamp).toLocaleString()}`
        );

        // Restore content
        editor.commands.setContent(content);

        // Mark document as dirty (needs save)
        markDirty();

        // Reload versions list to show the backup checkpoint
        await loadVersions();

        console.debug('[VersionHistory] Restored version:', selectedVersion.id);
        return true;
      } catch (err) {
        console.error('[VersionHistory] Failed to restore version:', err);
        return false;
      }
    },
    [selectedVersion, documentPath, markDirty, loadVersions]
  );

  // Create a named checkpoint
  const createCheckpoint = useCallback(
    async (editor: Editor, name: string): Promise<boolean> => {
      if (!documentPath) {
        return false;
      }

      try {
        const editorJSON = editor.getJSON();
        const wordCount = editor.storage.characterCount?.words?.() ?? 0;
        const charCount = editor.storage.characterCount?.characters?.() ?? 0;

        await saveVersion(
          documentPath,
          editorJSON,
          wordCount,
          charCount,
          true, // Named checkpoint
          name
        );

        // Reload versions list
        await loadVersions();

        console.debug('[VersionHistory] Created checkpoint:', name);
        return true;
      } catch (err) {
        console.error('[VersionHistory] Failed to create checkpoint:', err);
        return false;
      }
    },
    [documentPath, loadVersions]
  );

  // Clear selection
  const clearSelection = useCallback(() => {
    setSelectedVersion(null);
  }, []);

  return {
    versions,
    selectedVersion,
    isLoading,
    loadVersions,
    selectVersion,
    restoreVersion,
    createCheckpoint,
    clearSelection,
  };
}
```

2. Update `src/hooks/index.ts` to export the new hook:
   Add: `export { useVersionHistory } from './useVersionHistory'`
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    useVersionHistory hook created with loadVersions, selectVersion, restoreVersion, createCheckpoint functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VersionPreview component</name>
  <files>
    src/components/VersionHistory/VersionPreview.tsx
    src/components/VersionHistory/index.ts
  </files>
  <action>
1. Create directory: `src/components/VersionHistory/`

2. Create `src/components/VersionHistory/VersionPreview.tsx`:

```typescript
/**
 * Version Preview Component
 * Read-only display of a version's content
 */
import { useMemo } from 'react';
import type { Version } from '../../lib/version-storage';

interface InterfaceColors {
  bg: string;
  bgSurface: string;
  border: string;
  textPrimary: string;
  textSecondary: string;
  textMuted: string;
}

interface VersionPreviewProps {
  version: Version | null;
  interfaceColors: InterfaceColors;
}

export function VersionPreview({ version, interfaceColors }: VersionPreviewProps) {
  // Parse and render version content as HTML
  const htmlContent = useMemo(() => {
    if (!version) return '';

    try {
      const json = JSON.parse(version.content);
      // Simple JSON to HTML conversion for preview
      // This is read-only so we don't need full TipTap rendering
      return jsonToPreviewHTML(json);
    } catch (err) {
      console.error('[VersionPreview] Failed to parse version content:', err);
      return '<p style="color: red;">Failed to load preview</p>';
    }
  }, [version]);

  if (!version) {
    return (
      <div
        className="flex-1 flex items-center justify-center"
        style={{ color: interfaceColors.textMuted }}
      >
        <p className="text-sm">Select a version to preview</p>
      </div>
    );
  }

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {/* Preview header */}
      <div
        className="shrink-0 px-4 py-2 text-xs"
        style={{
          backgroundColor: interfaceColors.bgSurface,
          borderBottom: `1px solid ${interfaceColors.border}`,
          color: interfaceColors.textMuted,
        }}
      >
        {version.is_checkpoint && version.checkpoint_name ? (
          <span className="font-medium" style={{ color: interfaceColors.textPrimary }}>
            {version.checkpoint_name}
          </span>
        ) : (
          <span>Auto-save</span>
        )}
        <span className="mx-2">|</span>
        <span>{new Date(version.timestamp).toLocaleString()}</span>
        <span className="mx-2">|</span>
        <span>{version.word_count.toLocaleString()} words</span>
      </div>

      {/* Preview content */}
      <div
        className="flex-1 overflow-y-auto p-6"
        style={{
          backgroundColor: interfaceColors.bg,
          color: interfaceColors.textPrimary,
        }}
      >
        <div
          className="prose prose-sm max-w-none"
          style={{
            fontSize: '14px',
            lineHeight: '1.6',
          }}
          dangerouslySetInnerHTML={{ __html: htmlContent }}
        />
      </div>
    </div>
  );
}

/**
 * Simple JSON to HTML conversion for preview
 * Not full fidelity - just enough to show content
 */
function jsonToPreviewHTML(doc: any): string {
  if (!doc.content) return '';

  return doc.content
    .map((node: any) => nodeToHTML(node))
    .join('');
}

function nodeToHTML(node: any): string {
  switch (node.type) {
    case 'paragraph':
      return `<p>${inlineHTML(node.content || [])}</p>`;

    case 'heading':
      const level = node.attrs?.level || 1;
      return `<h${level}>${inlineHTML(node.content || [])}</h${level}>`;

    case 'bulletList':
      const bulletItems = (node.content || [])
        .map((item: any) => `<li>${listItemHTML(item)}</li>`)
        .join('');
      return `<ul>${bulletItems}</ul>`;

    case 'orderedList':
      const orderedItems = (node.content || [])
        .map((item: any) => `<li>${listItemHTML(item)}</li>`)
        .join('');
      return `<ol>${orderedItems}</ol>`;

    case 'blockquote':
      const quoteContent = (node.content || [])
        .map((n: any) => nodeToHTML(n))
        .join('');
      return `<blockquote>${quoteContent}</blockquote>`;

    case 'codeBlock':
      const code = (node.content || [])
        .map((n: any) => escapeHTML(n.text || ''))
        .join('');
      return `<pre><code>${code}</code></pre>`;

    case 'horizontalRule':
      return '<hr />';

    case 'table':
      return tableToHTML(node);

    case 'callout':
      const calloutContent = (node.content || [])
        .map((n: any) => nodeToHTML(n))
        .join('');
      const color = node.attrs?.color || 'blue';
      return `<div class="callout" style="background: #f0f7ff; padding: 12px; border-left: 4px solid #0066cc; margin: 16px 0;">${calloutContent}</div>`;

    case 'image':
      const src = node.attrs?.src || '';
      const alt = node.attrs?.alt || '';
      return `<img src="${src}" alt="${escapeHTML(alt)}" style="max-width: 100%;" />`;

    default:
      if (node.content) {
        return node.content.map((n: any) => nodeToHTML(n)).join('');
      }
      return '';
  }
}

function inlineHTML(content: any[]): string {
  return content
    .map((node) => {
      if (node.type === 'text') {
        let text = escapeHTML(node.text || '');
        const marks = node.marks || [];

        for (const mark of marks) {
          switch (mark.type) {
            case 'bold':
            case 'strong':
              text = `<strong>${text}</strong>`;
              break;
            case 'italic':
            case 'em':
              text = `<em>${text}</em>`;
              break;
            case 'code':
              text = `<code>${text}</code>`;
              break;
            case 'strike':
              text = `<s>${text}</s>`;
              break;
            case 'link':
              text = `<a href="${escapeHTML(mark.attrs?.href || '')}">${text}</a>`;
              break;
          }
        }

        return text;
      }
      return '';
    })
    .join('');
}

function listItemHTML(item: any): string {
  return (item.content || [])
    .map((node: any) => {
      if (node.type === 'paragraph') {
        return inlineHTML(node.content || []);
      }
      return nodeToHTML(node);
    })
    .join('');
}

function tableToHTML(node: any): string {
  const rows = node.content || [];
  if (rows.length === 0) return '';

  const rowsHTML = rows
    .map((row: any) => {
      const cells = row.content || [];
      const cellsHTML = cells
        .map((cell: any) => {
          const isHeader = cell.type === 'tableHeader';
          const tag = isHeader ? 'th' : 'td';
          const content = (cell.content || [])
            .map((n: any) => inlineHTML(n.content || []))
            .join(' ');
          return `<${tag} style="border: 1px solid #ddd; padding: 8px;">${content}</${tag}>`;
        })
        .join('');
      return `<tr>${cellsHTML}</tr>`;
    })
    .join('');

  return `<table style="border-collapse: collapse; width: 100%;">${rowsHTML}</table>`;
}

function escapeHTML(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

export default VersionPreview;
```

3. Create `src/components/VersionHistory/index.ts`:
```typescript
export { VersionHistoryPanel } from './VersionHistoryPanel';
export { VersionPreview } from './VersionPreview';
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    VersionPreview component created with JSON-to-HTML conversion for read-only preview
  </done>
</task>

<task type="auto">
  <name>Task 3: Create VersionHistoryPanel component</name>
  <files>
    src/components/VersionHistory/VersionHistoryPanel.tsx
    src/styles/version-history.css
  </files>
  <action>
1. Create `src/components/VersionHistory/VersionHistoryPanel.tsx`:

```typescript
/**
 * Version History Panel
 * Full-screen modal showing version timeline with preview and restore
 */
import { useEffect, useCallback, useState } from 'react';
import type { Editor } from '@tiptap/core';
import { useVersionHistory } from '../../hooks/useVersionHistory';
import { VersionPreview } from './VersionPreview';
import type { Version } from '../../lib/version-storage';

interface InterfaceColors {
  bg: string;
  bgSurface: string;
  border: string;
  textPrimary: string;
  textSecondary: string;
  textMuted: string;
}

interface VersionHistoryPanelProps {
  isOpen: boolean;
  onClose: () => void;
  editor: Editor | null;
  interfaceColors: InterfaceColors;
}

export function VersionHistoryPanel({
  isOpen,
  onClose,
  editor,
  interfaceColors,
}: VersionHistoryPanelProps) {
  const {
    versions,
    selectedVersion,
    isLoading,
    loadVersions,
    selectVersion,
    restoreVersion,
    clearSelection,
  } = useVersionHistory();

  const [isRestoring, setIsRestoring] = useState(false);

  // Load versions when panel opens
  useEffect(() => {
    if (isOpen) {
      loadVersions();
    } else {
      clearSelection();
    }
  }, [isOpen, loadVersions, clearSelection]);

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  // Handle restore
  const handleRestore = useCallback(async () => {
    if (!editor || !selectedVersion || isRestoring) return;

    const confirmed = window.confirm(
      `Restore document to version from ${new Date(selectedVersion.timestamp).toLocaleString()}?\n\nYour current work will be saved as a checkpoint before restore.`
    );

    if (!confirmed) return;

    setIsRestoring(true);
    try {
      const success = await restoreVersion(editor);
      if (success) {
        onClose();
      } else {
        alert('Failed to restore version. Please try again.');
      }
    } finally {
      setIsRestoring(false);
    }
  }, [editor, selectedVersion, isRestoring, restoreVersion, onClose]);

  // Format relative time
  const formatRelativeTime = (timestamp: number): string => {
    const now = Date.now();
    const diff = now - timestamp;

    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;

    return new Date(timestamp).toLocaleDateString();
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex"
      style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}
      onClick={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div
        className="flex-1 flex m-8 rounded-lg overflow-hidden shadow-2xl"
        style={{ backgroundColor: interfaceColors.bg }}
      >
        {/* Left sidebar - version list */}
        <div
          className="w-72 flex flex-col shrink-0"
          style={{
            backgroundColor: interfaceColors.bgSurface,
            borderRight: `1px solid ${interfaceColors.border}`,
          }}
        >
          {/* Header */}
          <div
            className="p-4 shrink-0"
            style={{ borderBottom: `1px solid ${interfaceColors.border}` }}
          >
            <h2
              className="text-lg font-semibold"
              style={{ color: interfaceColors.textPrimary }}
            >
              Version History
            </h2>
            <p className="text-xs mt-1" style={{ color: interfaceColors.textMuted }}>
              {versions.length} version{versions.length !== 1 ? 's' : ''} saved
            </p>
          </div>

          {/* Version list */}
          <div className="flex-1 overflow-y-auto">
            {isLoading && versions.length === 0 ? (
              <div className="p-4 text-center">
                <p className="text-sm" style={{ color: interfaceColors.textMuted }}>
                  Loading versions...
                </p>
              </div>
            ) : versions.length === 0 ? (
              <div className="p-4 text-center">
                <p className="text-sm" style={{ color: interfaceColors.textMuted }}>
                  No versions saved yet.
                </p>
                <p className="text-xs mt-2" style={{ color: interfaceColors.textMuted }}>
                  Versions are created automatically every 30 seconds and when you save.
                </p>
              </div>
            ) : (
              <div className="py-2">
                {versions.map((version) => (
                  <VersionListItem
                    key={version.id}
                    version={version}
                    isSelected={selectedVersion?.id === version.id}
                    onSelect={() => selectVersion(version.id)}
                    formatRelativeTime={formatRelativeTime}
                    interfaceColors={interfaceColors}
                  />
                ))}
              </div>
            )}
          </div>
        </div>

        {/* Right side - preview */}
        <div className="flex-1 flex flex-col">
          {/* Preview header with restore button */}
          <div
            className="flex items-center justify-between p-4 shrink-0"
            style={{ borderBottom: `1px solid ${interfaceColors.border}` }}
          >
            <h3 className="font-medium" style={{ color: interfaceColors.textPrimary }}>
              Preview
            </h3>
            <div className="flex items-center gap-3">
              {selectedVersion && (
                <button
                  onClick={handleRestore}
                  disabled={isRestoring}
                  className="px-4 py-2 text-sm font-medium rounded transition-colors"
                  style={{
                    backgroundColor: '#0066cc',
                    color: '#ffffff',
                    opacity: isRestoring ? 0.5 : 1,
                    cursor: isRestoring ? 'not-allowed' : 'pointer',
                  }}
                >
                  {isRestoring ? 'Restoring...' : 'Restore This Version'}
                </button>
              )}
              <button
                onClick={onClose}
                className="px-4 py-2 text-sm rounded transition-colors"
                style={{
                  backgroundColor: interfaceColors.bgSurface,
                  border: `1px solid ${interfaceColors.border}`,
                  color: interfaceColors.textPrimary,
                }}
              >
                Close
              </button>
            </div>
          </div>

          {/* Preview content */}
          <VersionPreview
            version={selectedVersion}
            interfaceColors={interfaceColors}
          />
        </div>
      </div>
    </div>
  );
}

/**
 * Version list item
 */
interface VersionListItemProps {
  version: Version;
  isSelected: boolean;
  onSelect: () => void;
  formatRelativeTime: (timestamp: number) => string;
  interfaceColors: InterfaceColors;
}

function VersionListItem({
  version,
  isSelected,
  onSelect,
  formatRelativeTime,
  interfaceColors,
}: VersionListItemProps) {
  return (
    <button
      onClick={onSelect}
      className="w-full text-left px-4 py-3 transition-colors"
      style={{
        backgroundColor: isSelected ? interfaceColors.bg : 'transparent',
        borderLeft: isSelected ? `3px solid #0066cc` : '3px solid transparent',
      }}
    >
      <div className="flex items-center gap-2">
        {version.is_checkpoint && (
          <span
            className="px-1.5 py-0.5 text-[10px] font-medium rounded"
            style={{
              backgroundColor: '#0066cc20',
              color: '#0066cc',
            }}
          >
            Checkpoint
          </span>
        )}
        <span
          className="text-xs"
          style={{
            color: isSelected
              ? interfaceColors.textPrimary
              : interfaceColors.textMuted,
          }}
        >
          {formatRelativeTime(version.timestamp)}
        </span>
      </div>

      {version.is_checkpoint && version.checkpoint_name ? (
        <p
          className="text-sm font-medium mt-1 truncate"
          style={{ color: interfaceColors.textPrimary }}
        >
          {version.checkpoint_name}
        </p>
      ) : (
        <p
          className="text-sm mt-1"
          style={{ color: interfaceColors.textSecondary }}
        >
          Auto-save
        </p>
      )}

      <p
        className="text-xs mt-1"
        style={{ color: interfaceColors.textMuted }}
      >
        {version.word_count.toLocaleString()} words
      </p>
    </button>
  );
}

export default VersionHistoryPanel;
```

2. Create `src/styles/version-history.css`:

```css
/**
 * Version History Styles
 */

/* Version history panel animations */
.version-history-enter {
  opacity: 0;
  transform: scale(0.95);
}

.version-history-enter-active {
  opacity: 1;
  transform: scale(1);
  transition: opacity 0.2s ease, transform 0.2s ease;
}

.version-history-exit {
  opacity: 1;
  transform: scale(1);
}

.version-history-exit-active {
  opacity: 0;
  transform: scale(0.95);
  transition: opacity 0.2s ease, transform 0.2s ease;
}

/* Version list scrollbar */
.version-history-list::-webkit-scrollbar {
  width: 6px;
}

.version-history-list::-webkit-scrollbar-track {
  background: transparent;
}

.version-history-list::-webkit-scrollbar-thumb {
  background: rgba(128, 128, 128, 0.3);
  border-radius: 3px;
}

.version-history-list::-webkit-scrollbar-thumb:hover {
  background: rgba(128, 128, 128, 0.5);
}

/* Preview content prose styles */
.version-preview-content h1,
.version-preview-content h2,
.version-preview-content h3,
.version-preview-content h4,
.version-preview-content h5,
.version-preview-content h6 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: 600;
}

.version-preview-content p {
  margin: 1em 0;
}

.version-preview-content ul,
.version-preview-content ol {
  padding-left: 1.5em;
  margin: 1em 0;
}

.version-preview-content blockquote {
  border-left: 3px solid #ddd;
  margin: 1em 0;
  padding-left: 1em;
  color: #666;
}

.version-preview-content code {
  background-color: #f5f5f5;
  padding: 0.2em 0.4em;
  border-radius: 3px;
  font-size: 0.9em;
}

.version-preview-content pre {
  background-color: #f5f5f5;
  padding: 1em;
  border-radius: 4px;
  overflow-x: auto;
}
```

3. Update `src/components/VersionHistory/index.ts` to export VersionHistoryPanel:
   Already done in Task 2.
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    VersionHistoryPanel component created with version list, preview, and restore functionality
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes (no TypeScript errors)
2. Version history components exist: `ls src/components/VersionHistory/`
3. useVersionHistory hook exists: `ls src/hooks/useVersionHistory.ts`
4. Grep confirms restore function: `grep -n "restoreVersion" src/hooks/useVersionHistory.ts`
5. Grep confirms checkpoint creation: `grep -n "createCheckpoint" src/hooks/useVersionHistory.ts`
</verification>

<success_criteria>
- VersionHistoryPanel displays all saved versions for current document
- Version list shows checkpoints distinctly from auto-saves
- Preview displays version content in read-only format
- Restore creates backup checkpoint before restoring (undo safety)
- useVersionHistory hook manages version state and operations
- Relative time formatting (5m ago, 2h ago, 3d ago)
</success_criteria>

<output>
After completion, create `.planning/phases/05-polish/05-04-SUMMARY.md`
</output>
