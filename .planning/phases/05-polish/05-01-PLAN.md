---
phase: 05-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/lib.rs
  - src-tauri/migrations/001_versions.sql
  - src/lib/version-storage.ts
  - src/hooks/useAutoSnapshot.ts
autonomous: true

must_haves:
  truths:
    - "Document content auto-saves to SQLite every 30 seconds"
    - "Named checkpoints save on Cmd+S with user-provided name"
    - "Version records include content JSON, timestamp, word count"
  artifacts:
    - path: "src-tauri/Cargo.toml"
      provides: "tauri-plugin-sql dependency"
      contains: "tauri-plugin-sql"
    - path: "src-tauri/migrations/001_versions.sql"
      provides: "Database schema for versions table"
      contains: "CREATE TABLE versions"
    - path: "src/lib/version-storage.ts"
      provides: "CRUD operations for version history"
      exports: ["saveVersion", "getVersions", "deleteOldVersions"]
    - path: "src/hooks/useAutoSnapshot.ts"
      provides: "30-second debounced auto-save hook"
      exports: ["useAutoSnapshot"]
  key_links:
    - from: "src/hooks/useAutoSnapshot.ts"
      to: "src/lib/version-storage.ts"
      via: "saveVersion import"
      pattern: "import.*saveVersion.*from.*version-storage"
    - from: "src-tauri/src/lib.rs"
      to: "tauri_plugin_sql"
      via: "plugin registration"
      pattern: "tauri_plugin_sql::Builder"
---

<objective>
Set up SQLite infrastructure for version history storage with auto-snapshot capability.

Purpose: Foundation for Time Machine-style version recovery. Every 30 seconds, document state is captured to local SQLite database. Named checkpoints on explicit save allow user to mark important versions.

Output:
- Tauri SQL plugin configured with migrations
- Version storage functions (save, get, cleanup)
- Auto-snapshot hook ready for EditorWrapper integration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-polish/05-RESEARCH.md

# Existing patterns
@src-tauri/Cargo.toml
@src-tauri/src/lib.rs
@src/stores/editorStore.ts
@src/hooks/useAutoSave.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tauri-plugin-sql and create migration</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/migrations/001_versions.sql
  </files>
  <action>
1. Add tauri-plugin-sql to Cargo.toml:
   ```toml
   tauri-plugin-sql = { version = "2", features = ["sqlite"] }
   ```

2. Create migrations directory: `src-tauri/migrations/`

3. Create `001_versions.sql` migration:
   ```sql
   CREATE TABLE IF NOT EXISTS versions (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     document_path TEXT NOT NULL,
     content TEXT NOT NULL,
     timestamp INTEGER NOT NULL,
     is_checkpoint BOOLEAN NOT NULL DEFAULT 0,
     checkpoint_name TEXT,
     word_count INTEGER DEFAULT 0,
     char_count INTEGER DEFAULT 0
   );

   CREATE INDEX idx_versions_document_path ON versions(document_path);
   CREATE INDEX idx_versions_timestamp ON versions(timestamp DESC);
   ```

4. Update lib.rs to register plugin with migrations:
   ```rust
   use tauri_plugin_sql::{Builder as SqlBuilder, Migration, MigrationKind};

   // In run() function, add before other plugins:
   .plugin(
       SqlBuilder::default()
           .add_migrations(
               "sqlite:serq.db",
               vec![Migration {
                   version: 1,
                   description: "create_versions_table",
                   sql: include_str!("../migrations/001_versions.sql"),
                   kind: MigrationKind::Up,
               }],
           )
           .build(),
   )
   ```

Note: NEVER edit migrations after deployment. Use new migration files for schema changes.
  </action>
  <verify>
    Run `cd src-tauri && cargo check` - should compile without errors
  </verify>
  <done>
    tauri-plugin-sql installed, migration file exists, lib.rs registers SQL plugin with migration
  </done>
</task>

<task type="auto">
  <name>Task 2: Create version storage functions</name>
  <files>
    src/lib/version-storage.ts
  </files>
  <action>
1. Install frontend SQL package: `npm install @tauri-apps/plugin-sql`

2. Create `src/lib/version-storage.ts`:

```typescript
/**
 * Version Storage
 * SQLite operations for document version history
 */
import Database from '@tauri-apps/plugin-sql';

export interface Version {
  id: number;
  document_path: string;
  content: string;  // JSON.stringify(editor.getJSON())
  timestamp: number;
  is_checkpoint: boolean;
  checkpoint_name: string | null;
  word_count: number;
  char_count: number;
}

// Singleton database instance
let dbInstance: Awaited<ReturnType<typeof Database.load>> | null = null;

async function getDb() {
  if (!dbInstance) {
    dbInstance = await Database.load('sqlite:serq.db');
  }
  return dbInstance;
}

/**
 * Save a version snapshot
 */
export async function saveVersion(
  documentPath: string,
  editorJSON: object,
  wordCount: number,
  charCount: number,
  isCheckpoint: boolean = false,
  checkpointName?: string
): Promise<number> {
  const db = await getDb();

  const result = await db.execute(
    `INSERT INTO versions
     (document_path, content, timestamp, is_checkpoint, checkpoint_name, word_count, char_count)
     VALUES ($1, $2, $3, $4, $5, $6, $7)`,
    [
      documentPath,
      JSON.stringify(editorJSON),
      Date.now(),
      isCheckpoint ? 1 : 0,
      checkpointName || null,
      wordCount,
      charCount,
    ]
  );

  return result.lastInsertId;
}

/**
 * Get versions for a document, newest first
 */
export async function getVersions(documentPath: string, limit: number = 100): Promise<Version[]> {
  const db = await getDb();
  return await db.select<Version[]>(
    'SELECT * FROM versions WHERE document_path = $1 ORDER BY timestamp DESC LIMIT $2',
    [documentPath, limit]
  );
}

/**
 * Get a single version by ID
 */
export async function getVersionById(versionId: number): Promise<Version | null> {
  const db = await getDb();
  const results = await db.select<Version[]>(
    'SELECT * FROM versions WHERE id = $1',
    [versionId]
  );
  return results[0] || null;
}

/**
 * Delete old auto-save versions, keep last N per document
 * Always keeps all checkpoints
 */
export async function deleteOldVersions(documentPath: string, keepCount: number = 50): Promise<number> {
  const db = await getDb();

  const result = await db.execute(
    `DELETE FROM versions
     WHERE document_path = $1
       AND is_checkpoint = 0
       AND id NOT IN (
         SELECT id FROM versions
         WHERE document_path = $1 AND is_checkpoint = 0
         ORDER BY timestamp DESC
         LIMIT $2
       )`,
    [documentPath, keepCount]
  );

  return result.rowsAffected;
}

/**
 * Get checkpoint count for a document
 */
export async function getCheckpointCount(documentPath: string): Promise<number> {
  const db = await getDb();
  const result = await db.select<[{ count: number }]>(
    'SELECT COUNT(*) as count FROM versions WHERE document_path = $1 AND is_checkpoint = 1',
    [documentPath]
  );
  return result[0]?.count ?? 0;
}
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    version-storage.ts exports saveVersion, getVersions, getVersionById, deleteOldVersions, getCheckpointCount
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auto-snapshot hook</name>
  <files>
    src/hooks/useAutoSnapshot.ts
    src/hooks/index.ts
  </files>
  <action>
1. Create `src/hooks/useAutoSnapshot.ts`:

```typescript
/**
 * Auto-Snapshot Hook
 * Saves document version to SQLite every 30 seconds when document has unsaved changes
 */
import { useEffect, useRef } from 'react';
import { useDebouncedCallback } from 'use-debounce';
import type { Editor } from '@tiptap/core';
import { saveVersion, deleteOldVersions } from '../lib/version-storage';
import { useEditorStore } from '../stores/editorStore';

interface UseAutoSnapshotOptions {
  /** Debounce interval in ms (default: 30000 = 30 seconds) */
  debounceMs?: number;
  /** Whether auto-snapshot is enabled */
  enabled?: boolean;
}

export function useAutoSnapshot(
  editor: Editor | null,
  documentPath: string | null,
  options: UseAutoSnapshotOptions = {}
) {
  const { debounceMs = 30000, enabled = true } = options;
  const lastSnapshotRef = useRef<string | null>(null);

  // Debounced save function
  const performSnapshot = useDebouncedCallback(
    async () => {
      if (!enabled || !editor || !documentPath) {
        return;
      }

      const editorJSON = editor.getJSON();
      const contentString = JSON.stringify(editorJSON);

      // Skip if content hasn't changed since last snapshot
      if (contentString === lastSnapshotRef.current) {
        return;
      }

      // Get word/char count from CharacterCount extension storage
      const wordCount = editor.storage.characterCount?.words?.() ?? 0;
      const charCount = editor.storage.characterCount?.characters?.() ?? 0;

      try {
        await saveVersion(
          documentPath,
          editorJSON,
          wordCount,
          charCount,
          false, // Not a checkpoint (auto-save)
          undefined
        );

        lastSnapshotRef.current = contentString;
        console.debug('[AutoSnapshot] Saved version for:', documentPath);

        // Cleanup old versions periodically (keep last 50 auto-saves)
        await deleteOldVersions(documentPath, 50);
      } catch (err) {
        console.error('[AutoSnapshot] Failed to save version:', err);
      }
    },
    debounceMs,
    { maxWait: 60000 } // Force save at least every 60 seconds
  );

  // Subscribe to editor changes
  useEffect(() => {
    if (!enabled || !editor || !documentPath) return;

    const handleUpdate = () => {
      performSnapshot();
    };

    editor.on('update', handleUpdate);

    return () => {
      editor.off('update', handleUpdate);
    };
  }, [editor, documentPath, enabled, performSnapshot]);

  // Reset last snapshot when document changes
  useEffect(() => {
    lastSnapshotRef.current = null;
  }, [documentPath]);

  return {
    /** Manually trigger a snapshot (useful for checkpoints) */
    triggerSnapshot: performSnapshot,
  };
}
```

2. Update `src/hooks/index.ts` to export the new hook:
   Add: `export { useAutoSnapshot } from './useAutoSnapshot'`
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    useAutoSnapshot hook created with 30-second debounce, exports triggerSnapshot for manual checkpoints
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` passes
2. `npm run build` passes (no TypeScript errors)
3. `npm run tauri dev` starts without crashes
4. Grep confirms SQLite plugin in lib.rs: `grep -n "tauri_plugin_sql" src-tauri/src/lib.rs`
5. Grep confirms version storage exports: `grep -n "export" src/lib/version-storage.ts`
</verification>

<success_criteria>
- Tauri SQL plugin installed and registered with migration
- versions table schema defined (id, document_path, content, timestamp, is_checkpoint, checkpoint_name, word_count, char_count)
- version-storage.ts provides saveVersion, getVersions, getVersionById, deleteOldVersions functions
- useAutoSnapshot hook saves to SQLite every 30 seconds with content change detection
- Old auto-save versions cleaned up (keep last 50 per document)
</success_criteria>

<output>
After completion, create `.planning/phases/05-polish/05-01-SUMMARY.md`
</output>
