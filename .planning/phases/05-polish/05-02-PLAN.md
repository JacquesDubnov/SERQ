---
phase: 05-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/export-handlers.ts
  - src/components/ExportMenu/ExportMenu.tsx
  - src/styles/print.css
autonomous: true

must_haves:
  truths:
    - "User can export document to standalone HTML file"
    - "User can export document to Markdown format"
    - "User can export document to PDF via print dialog"
  artifacts:
    - path: "src/lib/export-handlers.ts"
      provides: "Export functions for HTML, Markdown, PDF"
      exports: ["exportToHTML", "exportToMarkdown", "exportToPDF"]
    - path: "src/components/ExportMenu/ExportMenu.tsx"
      provides: "Dropdown menu with export options"
      min_lines: 50
    - path: "src/styles/print.css"
      provides: "Print-specific styles for PDF export"
      contains: "@media print"
  key_links:
    - from: "src/components/ExportMenu/ExportMenu.tsx"
      to: "src/lib/export-handlers.ts"
      via: "export function imports"
      pattern: "import.*export.*from.*export-handlers"
---

<objective>
Create document export capabilities for HTML, Markdown, and PDF formats.

Purpose: Users need to share documents in standard formats. HTML provides full fidelity, Markdown for interop with other tools, PDF for printing and formal sharing.

Output:
- Export handler functions for each format
- Export menu component with format selection
- Print stylesheet for proper PDF output
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-polish/05-RESEARCH.md

# Existing patterns
@src/lib/serqFormat.ts
@src/stores/editorStore.ts
@src/stores/styleStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create export handler functions</name>
  <files>
    src/lib/export-handlers.ts
  </files>
  <action>
1. Create `src/lib/export-handlers.ts`:

```typescript
/**
 * Export Handlers
 * Functions for exporting TipTap content to various formats
 */
import type { Editor } from '@tiptap/core';
import { save } from '@tauri-apps/plugin-dialog';
import { writeTextFile } from '@tauri-apps/plugin-fs';

/**
 * Export to standalone HTML file
 * Includes inline styles for full visual fidelity
 */
export async function exportToHTML(
  editor: Editor,
  documentName: string
): Promise<boolean> {
  const content = editor.getHTML();

  // Get current CSS variables from document for inline styles
  const computedStyle = getComputedStyle(document.documentElement);
  const fontFamily = computedStyle.getPropertyValue('--font-family') || 'system-ui';
  const fontSize = computedStyle.getPropertyValue('--font-size') || '16px';
  const lineHeight = computedStyle.getPropertyValue('--line-height') || '1.6';
  const textColor = computedStyle.getPropertyValue('--color-text') || '#1a1a1a';
  const bgColor = computedStyle.getPropertyValue('--canvas-bg') || '#ffffff';

  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${documentName}</title>
  <style>
    body {
      font-family: ${fontFamily};
      font-size: ${fontSize};
      line-height: ${lineHeight};
      color: ${textColor};
      background-color: ${bgColor};
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
    }
    h1, h2, h3, h4, h5, h6 { margin-top: 1.5em; margin-bottom: 0.5em; }
    h1 { font-size: 2em; }
    h2 { font-size: 1.5em; }
    h3 { font-size: 1.25em; }
    p { margin: 1em 0; }
    ul, ol { padding-left: 1.5em; margin: 1em 0; }
    li { margin: 0.25em 0; }
    blockquote {
      border-left: 3px solid #ddd;
      margin: 1em 0;
      padding-left: 1em;
      color: #666;
    }
    code {
      background-color: #f5f5f5;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-size: 0.9em;
    }
    pre {
      background-color: #f5f5f5;
      padding: 1em;
      border-radius: 4px;
      overflow-x: auto;
    }
    pre code {
      background: none;
      padding: 0;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.5em;
      text-align: left;
    }
    th { background-color: #f5f5f5; }
    img { max-width: 100%; height: auto; }
    .callout {
      padding: 1em;
      border-radius: 4px;
      margin: 1em 0;
      border-left: 4px solid;
    }
    .callout[data-color="blue"] { background-color: #e7f3ff; border-left-color: #0969da; }
    .callout[data-color="green"] { background-color: #dafbe1; border-left-color: #1a7f37; }
    .callout[data-color="yellow"] { background-color: #fff8c5; border-left-color: #9a6700; }
    .callout[data-color="red"] { background-color: #ffebe9; border-left-color: #cf222e; }
    .callout[data-color="purple"] { background-color: #fbefff; border-left-color: #8250df; }
  </style>
</head>
<body>
${content}
</body>
</html>`;

  const defaultName = documentName.replace(/\.(serq\.html|html)$/i, '') + '.html';

  const filePath = await save({
    defaultPath: defaultName,
    filters: [{ name: 'HTML', extensions: ['html'] }],
  });

  if (filePath) {
    await writeTextFile(filePath, html);
    return true;
  }

  return false;
}

/**
 * Export to Markdown
 * Manual conversion from TipTap JSON to Markdown (no @tiptap/markdown extension needed)
 */
export async function exportToMarkdown(
  editor: Editor,
  documentName: string
): Promise<boolean> {
  const json = editor.getJSON();
  const markdown = jsonToMarkdown(json);

  const defaultName = documentName.replace(/\.(serq\.html|html)$/i, '') + '.md';

  const filePath = await save({
    defaultPath: defaultName,
    filters: [{ name: 'Markdown', extensions: ['md', 'markdown'] }],
  });

  if (filePath) {
    await writeTextFile(filePath, markdown);
    return true;
  }

  return false;
}

/**
 * Convert TipTap JSON to Markdown
 */
function jsonToMarkdown(doc: { type?: string; content?: any[]; attrs?: any; marks?: any[]; text?: string }): string {
  if (!doc.content) return '';

  return doc.content.map((node) => nodeToMarkdown(node)).join('\n\n');
}

function nodeToMarkdown(node: any): string {
  switch (node.type) {
    case 'paragraph':
      return inlineContent(node.content || []);

    case 'heading':
      const level = node.attrs?.level || 1;
      const hashes = '#'.repeat(level);
      return `${hashes} ${inlineContent(node.content || [])}`;

    case 'bulletList':
      return (node.content || [])
        .map((item: any) => `- ${listItemContent(item)}`)
        .join('\n');

    case 'orderedList':
      return (node.content || [])
        .map((item: any, i: number) => `${i + 1}. ${listItemContent(item)}`)
        .join('\n');

    case 'listItem':
      return listItemContent(node);

    case 'blockquote':
      const quoteContent = (node.content || [])
        .map((n: any) => nodeToMarkdown(n))
        .join('\n');
      return quoteContent.split('\n').map((line: string) => `> ${line}`).join('\n');

    case 'codeBlock':
      const lang = node.attrs?.language || '';
      const code = (node.content || [])
        .map((n: any) => n.text || '')
        .join('');
      return `\`\`\`${lang}\n${code}\n\`\`\``;

    case 'horizontalRule':
      return '---';

    case 'table':
      return tableToMarkdown(node);

    case 'callout':
      const calloutContent = (node.content || [])
        .map((n: any) => nodeToMarkdown(n))
        .join('\n');
      const icon = node.attrs?.icon || '';
      return `> ${icon} **Note**\n> ${calloutContent.split('\n').join('\n> ')}`;

    case 'image':
      const alt = node.attrs?.alt || 'image';
      const src = node.attrs?.src || '';
      return `![${alt}](${src})`;

    default:
      // Unknown node type, try to extract text
      if (node.content) {
        return (node.content || []).map((n: any) => nodeToMarkdown(n)).join('');
      }
      return '';
  }
}

function inlineContent(content: any[]): string {
  return content
    .map((node) => {
      if (node.type === 'text') {
        let text = node.text || '';

        // Apply marks
        const marks = node.marks || [];
        for (const mark of marks) {
          switch (mark.type) {
            case 'bold':
            case 'strong':
              text = `**${text}**`;
              break;
            case 'italic':
            case 'em':
              text = `*${text}*`;
              break;
            case 'code':
              text = `\`${text}\``;
              break;
            case 'strike':
              text = `~~${text}~~`;
              break;
            case 'link':
              text = `[${text}](${mark.attrs?.href || ''})`;
              break;
          }
        }

        return text;
      }
      return '';
    })
    .join('');
}

function listItemContent(item: any): string {
  return (item.content || [])
    .map((node: any) => {
      if (node.type === 'paragraph') {
        return inlineContent(node.content || []);
      }
      return nodeToMarkdown(node);
    })
    .join('\n');
}

function tableToMarkdown(node: any): string {
  const rows = node.content || [];
  if (rows.length === 0) return '';

  const tableRows: string[] = [];

  rows.forEach((row: any, rowIndex: number) => {
    const cells = row.content || [];
    const cellTexts = cells.map((cell: any) => {
      const content = cell.content || [];
      return content.map((n: any) => inlineContent(n.content || [])).join(' ');
    });

    tableRows.push(`| ${cellTexts.join(' | ')} |`);

    // Add separator after header row
    if (rowIndex === 0) {
      const separator = cells.map(() => '---').join(' | ');
      tableRows.push(`| ${separator} |`);
    }
  });

  return tableRows.join('\n');
}

/**
 * Export to PDF via browser print dialog
 */
export function exportToPDF(editor: Editor, documentName: string): void {
  const content = editor.getHTML();

  // Get current styles
  const computedStyle = getComputedStyle(document.documentElement);
  const fontFamily = computedStyle.getPropertyValue('--font-family') || 'system-ui';

  // Open print window
  const printWindow = window.open('', '_blank');

  if (!printWindow) {
    alert('Please allow pop-ups to export PDF');
    return;
  }

  printWindow.document.write(`<!DOCTYPE html>
<html>
<head>
  <title>${documentName}</title>
  <style>
    @media print {
      @page {
        margin: 1in;
        size: letter;
      }
    }
    body {
      font-family: ${fontFamily};
      font-size: 12pt;
      line-height: 1.5;
      color: #000;
      max-width: 100%;
      margin: 0;
      padding: 0;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1em;
      margin-bottom: 0.5em;
      page-break-after: avoid;
    }
    h1 { font-size: 18pt; }
    h2 { font-size: 14pt; }
    h3 { font-size: 12pt; }
    p { margin: 0.5em 0; }
    ul, ol { padding-left: 1.5em; margin: 0.5em 0; }
    blockquote {
      border-left: 2px solid #666;
      margin: 0.5em 0;
      padding-left: 1em;
      color: #333;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 0.5em 0;
      page-break-inside: avoid;
    }
    th, td {
      border: 1px solid #000;
      padding: 0.25em 0.5em;
    }
    th { background-color: #f0f0f0; }
    img { max-width: 100%; height: auto; }
    .callout {
      padding: 0.5em;
      margin: 0.5em 0;
      border: 1px solid #ccc;
      border-left: 3px solid #666;
    }
    pre, code {
      font-family: monospace;
      font-size: 10pt;
    }
    pre {
      white-space: pre-wrap;
      page-break-inside: avoid;
    }
  </style>
</head>
<body>
${content}
</body>
</html>`);

  printWindow.document.close();

  // Wait for content to load, then print
  printWindow.onload = () => {
    printWindow.print();
  };

  // Fallback if onload doesn't fire
  setTimeout(() => {
    printWindow.print();
  }, 500);
}
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    export-handlers.ts exports exportToHTML, exportToMarkdown, exportToPDF functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Export Menu component</name>
  <files>
    src/components/ExportMenu/ExportMenu.tsx
    src/components/ExportMenu/index.ts
  </files>
  <action>
1. Create directory: `src/components/ExportMenu/`

2. Create `src/components/ExportMenu/ExportMenu.tsx`:

```typescript
/**
 * Export Menu Component
 * Dropdown menu for selecting export format
 */
import { useState, useRef, useEffect, useCallback } from 'react';
import type { Editor } from '@tiptap/core';
import { exportToHTML, exportToMarkdown, exportToPDF } from '../../lib/export-handlers';
import { useEditorStore } from '../../stores/editorStore';

interface InterfaceColors {
  bg: string;
  bgSurface: string;
  border: string;
  textPrimary: string;
  textSecondary: string;
  textMuted: string;
}

interface ExportMenuProps {
  editor: Editor | null;
  interfaceColors: InterfaceColors;
}

type ExportFormat = 'html' | 'markdown' | 'pdf';

interface ExportOption {
  id: ExportFormat;
  name: string;
  description: string;
}

const EXPORT_OPTIONS: ExportOption[] = [
  { id: 'html', name: 'HTML', description: 'Self-contained HTML file with styles' },
  { id: 'markdown', name: 'Markdown', description: 'Plain text Markdown format' },
  { id: 'pdf', name: 'PDF', description: 'Print to PDF via system dialog' },
];

export function ExportMenu({ editor, interfaceColors }: ExportMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);
  const documentName = useEditorStore((state) => state.document.name);

  // Close on outside click
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setIsOpen(false);
      }
    };

    const timer = setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
    }, 100);

    return () => {
      clearTimeout(timer);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  // Close on Escape
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setIsOpen(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isOpen]);

  const handleExport = useCallback(
    async (format: ExportFormat) => {
      if (!editor || isExporting) return;

      setIsExporting(true);

      try {
        switch (format) {
          case 'html':
            await exportToHTML(editor, documentName);
            break;
          case 'markdown':
            await exportToMarkdown(editor, documentName);
            break;
          case 'pdf':
            exportToPDF(editor, documentName);
            break;
        }
      } catch (err) {
        console.error('Export failed:', err);
        alert(`Export failed: ${err instanceof Error ? err.message : 'Unknown error'}`);
      } finally {
        setIsExporting(false);
        setIsOpen(false);
      }
    },
    [editor, documentName, isExporting]
  );

  return (
    <div ref={menuRef} className="relative">
      {/* Export button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        disabled={!editor || isExporting}
        className="px-3 py-1.5 text-xs font-medium rounded transition-colors"
        style={{
          backgroundColor: interfaceColors.bgSurface,
          border: `1px solid ${interfaceColors.border}`,
          color: interfaceColors.textPrimary,
          opacity: !editor || isExporting ? 0.5 : 1,
          cursor: !editor || isExporting ? 'not-allowed' : 'pointer',
        }}
        title="Export document"
      >
        {isExporting ? 'Exporting...' : 'Export'}
      </button>

      {/* Dropdown menu */}
      {isOpen && (
        <div
          className="absolute top-full right-0 mt-1 rounded-md shadow-lg z-50"
          style={{
            backgroundColor: interfaceColors.bg,
            border: `1px solid ${interfaceColors.border}`,
            minWidth: '200px',
          }}
        >
          {EXPORT_OPTIONS.map((option) => (
            <button
              key={option.id}
              onClick={() => handleExport(option.id)}
              className="w-full text-left px-4 py-3 first:rounded-t-md last:rounded-b-md transition-colors hover:bg-opacity-50"
              style={{
                backgroundColor: 'transparent',
                color: interfaceColors.textPrimary,
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = interfaceColors.bgSurface;
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
            >
              <div className="font-medium text-sm">{option.name}</div>
              <div className="text-xs mt-0.5" style={{ color: interfaceColors.textMuted }}>
                {option.description}
              </div>
            </button>
          ))}
        </div>
      )}
    </div>
  );
}

export default ExportMenu;
```

3. Create `src/components/ExportMenu/index.ts`:
```typescript
export { ExportMenu } from './ExportMenu';
export { default } from './ExportMenu';
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    ExportMenu component created with dropdown for HTML/Markdown/PDF export options
  </done>
</task>

<task type="auto">
  <name>Task 3: Add export to command palette</name>
  <files>
    src/components/CommandPalette/commands.ts
  </files>
  <action>
1. Update `src/components/CommandPalette/commands.ts` to add export commands:

Add imports at top:
```typescript
import { exportToHTML, exportToMarkdown, exportToPDF } from '../../lib/export-handlers';
import { useEditorStore } from '../../stores/editorStore';
```

Add new export commands to the COMMANDS array (after existing commands):
```typescript
// Export commands
{
  id: 'export-html',
  title: 'Export to HTML',
  shortcut: undefined,
  group: 'file' as CommandGroup,
  action: (editor: Editor) => {
    const documentName = useEditorStore.getState().document.name;
    exportToHTML(editor, documentName);
  },
},
{
  id: 'export-markdown',
  title: 'Export to Markdown',
  shortcut: undefined,
  group: 'file' as CommandGroup,
  action: (editor: Editor) => {
    const documentName = useEditorStore.getState().document.name;
    exportToMarkdown(editor, documentName);
  },
},
{
  id: 'export-pdf',
  title: 'Export to PDF',
  shortcut: undefined,
  group: 'file' as CommandGroup,
  action: (editor: Editor) => {
    const documentName = useEditorStore.getState().document.name;
    exportToPDF(editor, documentName);
  },
},
```

Note: If 'file' group doesn't exist in CommandGroup type, add it to the union type.
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    Export commands (HTML, Markdown, PDF) available in command palette under 'file' group
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes (no TypeScript errors)
2. Grep confirms export functions: `grep -n "export.*function" src/lib/export-handlers.ts`
3. ExportMenu component exists: `ls src/components/ExportMenu/`
4. Command palette includes export: `grep -n "export-html" src/components/CommandPalette/commands.ts`
</verification>

<success_criteria>
- exportToHTML creates self-contained HTML file with inline styles
- exportToMarkdown converts TipTap JSON to proper Markdown syntax
- exportToPDF opens print dialog with print-optimized styling
- ExportMenu provides dropdown UI for format selection
- Export commands available in Cmd+K command palette
</success_criteria>

<output>
After completion, create `.planning/phases/05-polish/05-02-SUMMARY.md`
</output>
