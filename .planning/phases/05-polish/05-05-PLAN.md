---
phase: 05-polish
plan: 05
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/extensions/Comment/Comment.ts
  - src/components/Comments/CommentPanel.tsx
  - src/components/Comments/CommentMarker.tsx
  - src/lib/comment-storage.ts
  - src/stores/commentStore.ts
  - src/styles/comments.css
autonomous: true

must_haves:
  truths:
    - "User can add comment to selected text"
    - "Comments show as highlight marks in document"
    - "User can view all comments in side panel"
    - "User can resolve or delete comments"
  artifacts:
    - path: "src/extensions/Comment/Comment.ts"
      provides: "TipTap comment mark extension"
      exports: ["Comment"]
    - path: "src/components/Comments/CommentPanel.tsx"
      provides: "Side panel listing all comments"
      min_lines: 100
    - path: "src/stores/commentStore.ts"
      provides: "Comment state management"
      exports: ["useCommentStore"]
    - path: "src/lib/comment-storage.ts"
      provides: "SQLite storage for comment text"
      exports: ["saveComment", "getComments", "deleteComment"]
  key_links:
    - from: "src/extensions/Comment/Comment.ts"
      to: "src/stores/commentStore.ts"
      via: "store updates on comment changes"
      pattern: "useCommentStore"
    - from: "src/components/Comments/CommentPanel.tsx"
      to: "src/lib/comment-storage.ts"
      via: "comment CRUD operations"
      pattern: "import.*from.*comment-storage"
---

<objective>
Create single-user commenting system with inline highlights and side panel.

Purpose: Writers need to leave notes and reminders for themselves within documents. Comments appear as highlighted text with a side panel showing all comments, allowing quick navigation and resolution.

Output:
- Comment TipTap extension (mark-based highlighting)
- Comment panel for viewing and managing comments
- SQLite storage for comment text (separate from document JSON)
- Zustand store for comment state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-polish/05-RESEARCH.md
@.planning/phases/05-polish/05-01-SUMMARY.md

# Existing patterns
@src/extensions/Callout/Callout.ts
@src/components/DocumentOutline/OutlinePanel.tsx
@src/stores/editorStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comment storage and store</name>
  <files>
    src-tauri/migrations/002_comments.sql
    src-tauri/src/lib.rs
    src/lib/comment-storage.ts
    src/stores/commentStore.ts
  </files>
  <action>
1. Create `src-tauri/migrations/002_comments.sql`:

```sql
-- Comments table - stores comment text separately from document
CREATE TABLE IF NOT EXISTS comments (
  id TEXT PRIMARY KEY,
  document_path TEXT NOT NULL,
  text TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  resolved_at INTEGER,
  position_from INTEGER NOT NULL,
  position_to INTEGER NOT NULL
);

CREATE INDEX idx_comments_document_path ON comments(document_path);
CREATE INDEX idx_comments_resolved ON comments(resolved_at);
```

2. Update `src-tauri/src/lib.rs` to add the new migration:

In the migrations vec, add after the existing version 1 migration:
```rust
Migration {
    version: 2,
    description: "create_comments_table",
    sql: include_str!("../migrations/002_comments.sql"),
    kind: MigrationKind::Up,
}
```

3. Create `src/lib/comment-storage.ts`:

```typescript
/**
 * Comment Storage
 * SQLite operations for document comments
 */
import Database from '@tauri-apps/plugin-sql';

export interface CommentRecord {
  id: string;
  document_path: string;
  text: string;
  created_at: number;
  resolved_at: number | null;
  position_from: number;
  position_to: number;
}

// Reuse database singleton from version-storage
let dbInstance: Awaited<ReturnType<typeof Database.load>> | null = null;

async function getDb() {
  if (!dbInstance) {
    dbInstance = await Database.load('sqlite:serq.db');
  }
  return dbInstance;
}

/**
 * Save a new comment
 */
export async function saveComment(
  documentPath: string,
  commentId: string,
  text: string,
  positionFrom: number,
  positionTo: number
): Promise<void> {
  const db = await getDb();

  await db.execute(
    `INSERT INTO comments (id, document_path, text, created_at, resolved_at, position_from, position_to)
     VALUES ($1, $2, $3, $4, NULL, $5, $6)`,
    [commentId, documentPath, text, Date.now(), positionFrom, positionTo]
  );
}

/**
 * Get all comments for a document
 */
export async function getComments(documentPath: string): Promise<CommentRecord[]> {
  const db = await getDb();
  return await db.select<CommentRecord[]>(
    'SELECT * FROM comments WHERE document_path = $1 ORDER BY position_from ASC',
    [documentPath]
  );
}

/**
 * Get a single comment by ID
 */
export async function getCommentById(commentId: string): Promise<CommentRecord | null> {
  const db = await getDb();
  const results = await db.select<CommentRecord[]>(
    'SELECT * FROM comments WHERE id = $1',
    [commentId]
  );
  return results[0] || null;
}

/**
 * Update comment text
 */
export async function updateCommentText(
  commentId: string,
  newText: string
): Promise<void> {
  const db = await getDb();
  await db.execute(
    'UPDATE comments SET text = $1 WHERE id = $2',
    [newText, commentId]
  );
}

/**
 * Mark comment as resolved
 */
export async function resolveComment(commentId: string): Promise<void> {
  const db = await getDb();
  await db.execute(
    'UPDATE comments SET resolved_at = $1 WHERE id = $2',
    [Date.now(), commentId]
  );
}

/**
 * Unresolve a comment
 */
export async function unresolveComment(commentId: string): Promise<void> {
  const db = await getDb();
  await db.execute(
    'UPDATE comments SET resolved_at = NULL WHERE id = $1',
    [commentId]
  );
}

/**
 * Delete a comment
 */
export async function deleteComment(commentId: string): Promise<void> {
  const db = await getDb();
  await db.execute('DELETE FROM comments WHERE id = $1', [commentId]);
}

/**
 * Update comment positions (after document edits)
 */
export async function updateCommentPosition(
  commentId: string,
  newFrom: number,
  newTo: number
): Promise<void> {
  const db = await getDb();
  await db.execute(
    'UPDATE comments SET position_from = $1, position_to = $2 WHERE id = $3',
    [newFrom, newTo, commentId]
  );
}

/**
 * Delete all comments for a document
 */
export async function deleteAllCommentsForDocument(documentPath: string): Promise<void> {
  const db = await getDb();
  await db.execute('DELETE FROM comments WHERE document_path = $1', [documentPath]);
}
```

4. Create `src/stores/commentStore.ts`:

```typescript
/**
 * Comment Store
 * Zustand store for comment state management
 */
import { create } from 'zustand';
import type { CommentRecord } from '../lib/comment-storage';

export interface Comment {
  id: string;
  text: string;
  createdAt: number;
  resolvedAt: number | null;
  from: number;
  to: number;
}

interface CommentState {
  comments: Comment[];
  activeCommentId: string | null;
  isPanelOpen: boolean;

  // Actions
  setComments: (comments: Comment[]) => void;
  addComment: (comment: Comment) => void;
  updateComment: (id: string, updates: Partial<Comment>) => void;
  removeComment: (id: string) => void;
  setActiveComment: (id: string | null) => void;
  setPanelOpen: (open: boolean) => void;
  togglePanel: () => void;
}

export const useCommentStore = create<CommentState>((set) => ({
  comments: [],
  activeCommentId: null,
  isPanelOpen: false,

  setComments: (comments) => set({ comments }),

  addComment: (comment) =>
    set((state) => ({
      comments: [...state.comments, comment],
    })),

  updateComment: (id, updates) =>
    set((state) => ({
      comments: state.comments.map((c) =>
        c.id === id ? { ...c, ...updates } : c
      ),
    })),

  removeComment: (id) =>
    set((state) => ({
      comments: state.comments.filter((c) => c.id !== id),
      activeCommentId: state.activeCommentId === id ? null : state.activeCommentId,
    })),

  setActiveComment: (id) => set({ activeCommentId: id }),

  setPanelOpen: (open) => set({ isPanelOpen: open }),

  togglePanel: () => set((state) => ({ isPanelOpen: !state.isPanelOpen })),
}));

/**
 * Convert database record to store Comment
 */
export function recordToComment(record: CommentRecord): Comment {
  return {
    id: record.id,
    text: record.text,
    createdAt: record.created_at,
    resolvedAt: record.resolved_at,
    from: record.position_from,
    to: record.position_to,
  };
}

export type { CommentState };
```
  </action>
  <verify>
    Run `cd src-tauri && cargo check` and `npm run build` - both pass
  </verify>
  <done>
    Comment storage (SQLite) and Zustand store created with CRUD operations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Comment TipTap extension</name>
  <files>
    src/extensions/Comment/Comment.ts
    src/extensions/Comment/index.ts
  </files>
  <action>
1. Create directory: `src/extensions/Comment/`

2. Create `src/extensions/Comment/Comment.ts`:

```typescript
/**
 * Comment Extension
 * Mark-based comment highlighting for TipTap
 * Stores comment ID in mark attribute, actual text in SQLite
 */
import { Mark, mergeAttributes } from '@tiptap/core';

export interface CommentOptions {
  HTMLAttributes: Record<string, any>;
  onCommentActivated?: (commentId: string) => void;
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    comment: {
      /**
       * Set a comment mark on the current selection
       */
      setComment: (attributes: { id: string }) => ReturnType;
      /**
       * Unset the comment mark
       */
      unsetComment: () => ReturnType;
    };
  }
}

export const Comment = Mark.create<CommentOptions>({
  name: 'comment',

  addOptions() {
    return {
      HTMLAttributes: {
        class: 'comment-mark',
      },
      onCommentActivated: undefined,
    };
  },

  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute('data-comment-id'),
        renderHTML: (attributes) => {
          if (!attributes.id) return {};
          return {
            'data-comment-id': attributes.id,
          };
        },
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-comment-id]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'span',
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      0,
    ];
  },

  addCommands() {
    return {
      setComment:
        (attributes) =>
        ({ commands }) => {
          return commands.setMark(this.name, attributes);
        },

      unsetComment:
        () =>
        ({ commands }) => {
          return commands.unsetMark(this.name);
        },
    };
  },

  // Handle click on comment to activate it
  addProseMirrorPlugins() {
    const extension = this;

    return [
      {
        key: new (require('@tiptap/pm/state').PluginKey)('commentClick'),
        props: {
          handleClick(view, pos, event) {
            const target = event.target as HTMLElement;
            const commentMark = target.closest('[data-comment-id]');

            if (commentMark) {
              const commentId = commentMark.getAttribute('data-comment-id');
              if (commentId && extension.options.onCommentActivated) {
                extension.options.onCommentActivated(commentId);
              }
            }

            return false; // Don't prevent default
          },
        },
      },
    ];
  },
});

export default Comment;
```

3. Create `src/extensions/Comment/index.ts`:

```typescript
export { Comment } from './Comment';
export { default } from './Comment';
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    Comment TipTap extension created with setComment/unsetComment commands and click handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CommentPanel component</name>
  <files>
    src/components/Comments/CommentPanel.tsx
    src/components/Comments/index.ts
    src/styles/comments.css
  </files>
  <action>
1. Create directory: `src/components/Comments/`

2. Create `src/components/Comments/CommentPanel.tsx`:

```typescript
/**
 * Comment Panel
 * Side panel for viewing and managing document comments
 */
import { useEffect, useCallback, useRef, useState } from 'react';
import type { Editor } from '@tiptap/core';
import { useCommentStore, type Comment } from '../../stores/commentStore';
import {
  resolveComment,
  unresolveComment,
  deleteComment as deleteCommentFromDB,
  updateCommentText,
} from '../../lib/comment-storage';

interface InterfaceColors {
  bg: string;
  bgSurface: string;
  border: string;
  textPrimary: string;
  textSecondary: string;
  textMuted: string;
}

interface CommentPanelProps {
  editor: Editor | null;
  interfaceColors: InterfaceColors;
}

export function CommentPanel({ editor, interfaceColors }: CommentPanelProps) {
  const panelRef = useRef<HTMLDivElement>(null);
  const {
    comments,
    activeCommentId,
    isPanelOpen,
    setActiveComment,
    updateComment,
    removeComment,
    setPanelOpen,
  } = useCommentStore();

  const [editingId, setEditingId] = useState<string | null>(null);
  const [editText, setEditText] = useState('');

  // Keyboard handling
  useEffect(() => {
    if (!isPanelOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (editingId) {
          setEditingId(null);
        } else {
          setPanelOpen(false);
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isPanelOpen, editingId, setPanelOpen]);

  // Navigate to comment in editor
  const navigateToComment = useCallback(
    (comment: Comment) => {
      if (!editor) return;

      setActiveComment(comment.id);

      // Focus and select the commented text
      editor.chain().focus().setTextSelection({ from: comment.from, to: comment.to }).run();

      // Scroll into view
      const view = editor.view;
      const domAtPos = view.domAtPos(comment.from);
      if (domAtPos.node instanceof HTMLElement) {
        domAtPos.node.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    },
    [editor, setActiveComment]
  );

  // Resolve/unresolve comment
  const handleToggleResolve = useCallback(
    async (comment: Comment) => {
      try {
        if (comment.resolvedAt) {
          await unresolveComment(comment.id);
          updateComment(comment.id, { resolvedAt: null });
        } else {
          await resolveComment(comment.id);
          updateComment(comment.id, { resolvedAt: Date.now() });
        }
      } catch (err) {
        console.error('[CommentPanel] Failed to toggle resolve:', err);
      }
    },
    [updateComment]
  );

  // Delete comment
  const handleDelete = useCallback(
    async (comment: Comment) => {
      if (!editor) return;

      const confirmed = window.confirm('Delete this comment?');
      if (!confirmed) return;

      try {
        // Remove mark from editor
        editor
          .chain()
          .focus()
          .setTextSelection({ from: comment.from, to: comment.to })
          .unsetComment()
          .run();

        // Delete from database
        await deleteCommentFromDB(comment.id);

        // Remove from store
        removeComment(comment.id);
      } catch (err) {
        console.error('[CommentPanel] Failed to delete comment:', err);
      }
    },
    [editor, removeComment]
  );

  // Start editing
  const startEditing = useCallback((comment: Comment) => {
    setEditingId(comment.id);
    setEditText(comment.text);
  }, []);

  // Save edit
  const saveEdit = useCallback(
    async (commentId: string) => {
      try {
        await updateCommentText(commentId, editText);
        updateComment(commentId, { text: editText });
        setEditingId(null);
      } catch (err) {
        console.error('[CommentPanel] Failed to update comment:', err);
      }
    },
    [editText, updateComment]
  );

  // Separate resolved and unresolved comments
  const unresolvedComments = comments.filter((c) => !c.resolvedAt);
  const resolvedComments = comments.filter((c) => c.resolvedAt);

  if (!isPanelOpen) return null;

  return (
    <div
      ref={panelRef}
      className="fixed right-0 top-0 bottom-0 flex flex-col z-40"
      style={{
        width: '320px',
        backgroundColor: interfaceColors.bg,
        borderLeft: `1px solid ${interfaceColors.border}`,
        boxShadow: '-4px 0 20px rgba(0, 0, 0, 0.15)',
      }}
    >
      {/* Header */}
      <div
        className="flex items-center justify-between shrink-0 p-4"
        style={{
          backgroundColor: interfaceColors.bgSurface,
          borderBottom: `1px solid ${interfaceColors.border}`,
        }}
      >
        <h2 className="font-semibold" style={{ color: interfaceColors.textPrimary }}>
          Comments
        </h2>
        <button
          onClick={() => setPanelOpen(false)}
          className="text-lg leading-none opacity-60 hover:opacity-100 transition-opacity"
          style={{ color: interfaceColors.textPrimary }}
        >
          x
        </button>
      </div>

      {/* Comment list */}
      <div className="flex-1 overflow-y-auto">
        {comments.length === 0 ? (
          <div className="p-4 text-center">
            <p className="text-sm" style={{ color: interfaceColors.textMuted }}>
              No comments yet.
            </p>
            <p className="text-xs mt-2" style={{ color: interfaceColors.textMuted }}>
              Select text and use Cmd+K {">"} "Add Comment" to create one.
            </p>
          </div>
        ) : (
          <>
            {/* Unresolved comments */}
            {unresolvedComments.length > 0 && (
              <div className="p-2">
                <p
                  className="text-xs font-medium px-2 py-1"
                  style={{ color: interfaceColors.textMuted }}
                >
                  Open ({unresolvedComments.length})
                </p>
                {unresolvedComments.map((comment) => (
                  <CommentItem
                    key={comment.id}
                    comment={comment}
                    isActive={activeCommentId === comment.id}
                    isEditing={editingId === comment.id}
                    editText={editText}
                    onEditTextChange={setEditText}
                    onNavigate={navigateToComment}
                    onToggleResolve={handleToggleResolve}
                    onDelete={handleDelete}
                    onStartEdit={startEditing}
                    onSaveEdit={saveEdit}
                    onCancelEdit={() => setEditingId(null)}
                    interfaceColors={interfaceColors}
                  />
                ))}
              </div>
            )}

            {/* Resolved comments */}
            {resolvedComments.length > 0 && (
              <div className="p-2">
                <p
                  className="text-xs font-medium px-2 py-1"
                  style={{ color: interfaceColors.textMuted }}
                >
                  Resolved ({resolvedComments.length})
                </p>
                {resolvedComments.map((comment) => (
                  <CommentItem
                    key={comment.id}
                    comment={comment}
                    isActive={activeCommentId === comment.id}
                    isEditing={editingId === comment.id}
                    editText={editText}
                    onEditTextChange={setEditText}
                    onNavigate={navigateToComment}
                    onToggleResolve={handleToggleResolve}
                    onDelete={handleDelete}
                    onStartEdit={startEditing}
                    onSaveEdit={saveEdit}
                    onCancelEdit={() => setEditingId(null)}
                    interfaceColors={interfaceColors}
                  />
                ))}
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}

/**
 * Individual comment item
 */
interface CommentItemProps {
  comment: Comment;
  isActive: boolean;
  isEditing: boolean;
  editText: string;
  onEditTextChange: (text: string) => void;
  onNavigate: (comment: Comment) => void;
  onToggleResolve: (comment: Comment) => void;
  onDelete: (comment: Comment) => void;
  onStartEdit: (comment: Comment) => void;
  onSaveEdit: (id: string) => void;
  onCancelEdit: () => void;
  interfaceColors: InterfaceColors;
}

function CommentItem({
  comment,
  isActive,
  isEditing,
  editText,
  onEditTextChange,
  onNavigate,
  onToggleResolve,
  onDelete,
  onStartEdit,
  onSaveEdit,
  onCancelEdit,
  interfaceColors,
}: CommentItemProps) {
  const isResolved = !!comment.resolvedAt;

  return (
    <div
      className="rounded-md mb-2 p-3 transition-colors cursor-pointer"
      style={{
        backgroundColor: isActive ? interfaceColors.bgSurface : 'transparent',
        border: `1px solid ${isActive ? interfaceColors.border : 'transparent'}`,
        opacity: isResolved ? 0.6 : 1,
      }}
      onClick={() => onNavigate(comment)}
    >
      {isEditing ? (
        <div onClick={(e) => e.stopPropagation()}>
          <textarea
            value={editText}
            onChange={(e) => onEditTextChange(e.target.value)}
            className="w-full p-2 text-sm rounded border resize-none"
            style={{
              backgroundColor: interfaceColors.bg,
              borderColor: interfaceColors.border,
              color: interfaceColors.textPrimary,
            }}
            rows={3}
            autoFocus
          />
          <div className="flex gap-2 mt-2">
            <button
              onClick={() => onSaveEdit(comment.id)}
              className="px-2 py-1 text-xs rounded"
              style={{
                backgroundColor: '#0066cc',
                color: '#fff',
              }}
            >
              Save
            </button>
            <button
              onClick={onCancelEdit}
              className="px-2 py-1 text-xs rounded"
              style={{
                backgroundColor: interfaceColors.bgSurface,
                color: interfaceColors.textPrimary,
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      ) : (
        <>
          <p
            className="text-sm"
            style={{
              color: interfaceColors.textPrimary,
              textDecoration: isResolved ? 'line-through' : 'none',
            }}
          >
            {comment.text}
          </p>
          <p
            className="text-xs mt-1"
            style={{ color: interfaceColors.textMuted }}
          >
            {new Date(comment.createdAt).toLocaleString()}
          </p>
          <div
            className="flex gap-2 mt-2"
            onClick={(e) => e.stopPropagation()}
          >
            <button
              onClick={() => onToggleResolve(comment)}
              className="text-xs hover:underline"
              style={{ color: interfaceColors.textSecondary }}
            >
              {isResolved ? 'Unresolve' : 'Resolve'}
            </button>
            <button
              onClick={() => onStartEdit(comment)}
              className="text-xs hover:underline"
              style={{ color: interfaceColors.textSecondary }}
            >
              Edit
            </button>
            <button
              onClick={() => onDelete(comment)}
              className="text-xs hover:underline"
              style={{ color: '#dc2626' }}
            >
              Delete
            </button>
          </div>
        </>
      )}
    </div>
  );
}

export default CommentPanel;
```

3. Create `src/components/Comments/index.ts`:

```typescript
export { CommentPanel } from './CommentPanel';
export { default } from './CommentPanel';
```

4. Create `src/styles/comments.css`:

```css
/**
 * Comment Styles
 */

/* Comment mark in editor */
.comment-mark {
  background-color: rgba(255, 220, 0, 0.3);
  border-bottom: 2px solid rgba(255, 180, 0, 0.6);
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.comment-mark:hover {
  background-color: rgba(255, 220, 0, 0.5);
}

/* Active comment highlight */
.comment-mark[data-active="true"],
.comment-mark.active {
  background-color: rgba(255, 200, 0, 0.5);
  border-bottom-color: rgba(255, 150, 0, 0.8);
}

/* Resolved comment mark (more subtle) */
.comment-mark[data-resolved="true"] {
  background-color: rgba(200, 200, 200, 0.2);
  border-bottom: 1px dashed rgba(150, 150, 150, 0.5);
}

/* Comment panel scrollbar */
.comment-panel::-webkit-scrollbar {
  width: 6px;
}

.comment-panel::-webkit-scrollbar-track {
  background: transparent;
}

.comment-panel::-webkit-scrollbar-thumb {
  background: rgba(128, 128, 128, 0.3);
  border-radius: 3px;
}

.comment-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(128, 128, 128, 0.5);
}

/* Dark mode adjustments */
:root[data-theme="dark"] .comment-mark {
  background-color: rgba(255, 200, 0, 0.2);
  border-bottom-color: rgba(255, 180, 0, 0.4);
}

:root[data-theme="dark"] .comment-mark:hover {
  background-color: rgba(255, 200, 0, 0.35);
}
```
  </action>
  <verify>
    Run `npm run build` - TypeScript compiles without errors
  </verify>
  <done>
    CommentPanel component created with comment list, navigation, resolve/delete functionality
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` passes
2. `npm run build` passes (no TypeScript errors)
3. Comment extension exists: `ls src/extensions/Comment/`
4. Comment panel exists: `ls src/components/Comments/`
5. Comment store exists: `ls src/stores/commentStore.ts`
6. Grep confirms comment storage exports: `grep -n "export" src/lib/comment-storage.ts`
7. Migration file exists: `ls src-tauri/migrations/002_comments.sql`
</verification>

<success_criteria>
- Comment TipTap extension adds yellow highlight marks with data-comment-id attribute
- Click on comment mark activates comment in panel
- CommentPanel shows all comments grouped by resolved/unresolved
- Users can navigate to comment location by clicking in panel
- Users can resolve, unresolve, edit, and delete comments
- Comment text stored in SQLite separately from document JSON
- CSS provides visual distinction for active and resolved comments
</success_criteria>

<output>
After completion, create `.planning/phases/05-polish/05-05-SUMMARY.md`
</output>
