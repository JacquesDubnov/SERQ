---
phase: 02-file-management
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/hooks/useFileOperations.ts
  - src/hooks/useKeyboardShortcuts.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "User can open .serq.html files via native macOS dialog"
    - "User can save document to disk with Cmd+S"
    - "User can save as new file with Cmd+Shift+S"
    - "User can create new empty document with Cmd+N"
    - "User can open files with Cmd+O"
    - "New documents without path trigger Save As dialog on Cmd+S"
  artifacts:
    - path: "src/hooks/useFileOperations.ts"
      provides: "File operation functions"
      exports: ["useFileOperations"]
      min_lines: 80
    - path: "src/hooks/useKeyboardShortcuts.ts"
      provides: "Global keyboard shortcut handlers"
      exports: ["useKeyboardShortcuts"]
      min_lines: 40
    - path: "src/hooks/index.ts"
      provides: "Barrel export for hooks"
      exports: ["useFileOperations", "useKeyboardShortcuts"]
  key_links:
    - from: "src/hooks/useFileOperations.ts"
      to: "@tauri-apps/plugin-dialog"
      via: "open() and save() for native dialogs"
      pattern: "import.*from '@tauri-apps/plugin-dialog'"
    - from: "src/hooks/useFileOperations.ts"
      to: "@tauri-apps/plugin-fs"
      via: "readTextFile() and writeTextFile()"
      pattern: "import.*from '@tauri-apps/plugin-fs'"
    - from: "src/hooks/useFileOperations.ts"
      to: "src/lib/serqFormat.ts"
      via: "serialize/parse document format"
      pattern: "import.*from.*serqFormat"
    - from: "src/hooks/useKeyboardShortcuts.ts"
      to: "src/hooks/useFileOperations.ts"
      via: "shortcuts trigger file operations"
      pattern: "useFileOperations"
---

<objective>
Create file operation hooks and keyboard shortcuts for open/save/save-as/new document functionality.

Purpose: This is the core file management layer that connects user actions (keyboard shortcuts, menu items) to Tauri file system operations via the .serq.html format.

Output:
- `useFileOperations` hook with openFile, saveFile, saveFileAs, newFile
- `useKeyboardShortcuts` hook binding Cmd+S/Shift+S/O/N
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-file-management/02-RESEARCH.md
@.planning/phases/02-file-management/02-01-SUMMARY.md

# Existing code to integrate with
@src/stores/editorStore.ts
@src/lib/serqFormat.ts
@src/components/Editor/EditorCore.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFileOperations hook</name>
  <files>
    - src/hooks/useFileOperations.ts
    - src/hooks/index.ts
  </files>
  <action>
    Create `src/hooks/` directory if it doesn't exist.

    Create `src/hooks/useFileOperations.ts`:

    The hook should:
    1. Accept an `editorRef: React.RefObject<EditorCoreRef>` parameter
    2. Use Zustand store actions (setDocument, markDirty, markSaved, clearDocument)
    3. Return { openFile, saveFile, saveFileAs, newFile }

    Implementation details:

    **openFile():**
    - Call `open()` from @tauri-apps/plugin-dialog with filter for .serq.html and .html
    - If user cancels (returns null), do nothing
    - Read file content via `readTextFile()` from @tauri-apps/plugin-fs
    - Parse with `parseSerqDocument()` to get HTML + metadata
    - Set editor content via `editorRef.current?.setContent(html)`
    - Update store with file path and name
    - Return { html, metadata } for caller if needed

    **saveFile():**
    - Get document state from store
    - If no path (new document), delegate to saveFileAs()
    - Get HTML from editor via `editorRef.current?.getHTML()`
    - Serialize with `serializeSerqDocument()`
    - Write via `writeTextFile()`
    - Call `markSaved()` on success

    **saveFileAs():**
    - Call `save()` from @tauri-apps/plugin-dialog with .serq.html filter
    - If user cancels, do nothing
    - Get HTML from editor
    - Serialize with document name extracted from path
    - Write to new path
    - Update store with new path/name
    - Call `markSaved()` on success
    - Return new file path

    **newFile():**
    - Check if current document is dirty
    - If dirty, could prompt (but for v1, just proceed - no confirmation dialog yet)
    - Call `editorRef.current?.setContent('')`
    - Call `clearDocument()` to reset store to Untitled

    Helper function:
    ```typescript
    function extractFileName(path: string): string {
      return path.split('/').pop()?.replace('.serq.html', '').replace('.html', '') ?? 'Untitled'
    }
    ```

    Create `src/hooks/index.ts` as barrel export:
    ```typescript
    export { useFileOperations } from './useFileOperations'
    ```
  </action>
  <verify>
    - File exists at `src/hooks/useFileOperations.ts`
    - `npx tsc --noEmit` passes
    - Hook imports from @tauri-apps/plugin-dialog and @tauri-apps/plugin-fs
    - Hook imports from src/lib/serqFormat
    - Hook exports openFile, saveFile, saveFileAs, newFile functions
  </verify>
  <done>
    useFileOperations hook created with all four file operations (open, save, save-as, new) using Tauri plugins and .serq.html format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useKeyboardShortcuts hook</name>
  <files>
    - src/hooks/useKeyboardShortcuts.ts
    - src/hooks/index.ts
  </files>
  <action>
    Create `src/hooks/useKeyboardShortcuts.ts`:

    The hook should:
    1. Accept an `editorRef: React.RefObject<EditorCoreRef>` parameter
    2. Initialize useFileOperations internally
    3. Register shortcuts with react-hotkeys-hook's useHotkeys

    Shortcuts to register:
    - `meta+s` and `ctrl+s` -> saveFile()
    - `meta+shift+s` and `ctrl+shift+s` -> saveFileAs()
    - `meta+o` and `ctrl+o` -> openFile()
    - `meta+n` and `ctrl+n` -> newFile()

    Each shortcut handler should:
    1. Call `e.preventDefault()` to stop browser default behavior
    2. Call the corresponding file operation

    Use these options for all shortcuts:
    ```typescript
    {
      enableOnContentEditable: true,  // Work when cursor is in TipTap
      enableOnFormTags: true,         // Work in any input context
    }
    ```

    Update `src/hooks/index.ts` to also export useKeyboardShortcuts:
    ```typescript
    export { useFileOperations } from './useFileOperations'
    export { useKeyboardShortcuts } from './useKeyboardShortcuts'
    ```

    IMPORTANT: react-hotkeys-hook uses lowercase key names and + for modifiers:
    - macOS Command = 'meta'
    - Windows/Linux Ctrl = 'ctrl'
    - Shift = 'shift'
    - Combined: 'meta+shift+s' (not 'Mod-Shift-s')
  </action>
  <verify>
    - File exists at `src/hooks/useKeyboardShortcuts.ts`
    - `npx tsc --noEmit` passes
    - Hook imports from 'react-hotkeys-hook'
    - Hook calls useHotkeys for each shortcut
    - Hook is exported from index.ts
  </verify>
  <done>
    useKeyboardShortcuts hook created with Cmd+S, Cmd+Shift+S, Cmd+O, Cmd+N bindings that trigger file operations.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Both hooks can be imported: `import { useFileOperations, useKeyboardShortcuts } from './hooks'`
3. No circular dependencies (hooks -> lib, not lib -> hooks)
</verification>

<success_criteria>
- useFileOperations exports openFile, saveFile, saveFileAs, newFile
- useKeyboardShortcuts registers all four keyboard shortcuts
- Hooks integrate with editorStore for state management
- Hooks use .serq.html format for document persistence
- TypeScript types are correct for EditorCoreRef integration
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-management/02-02-SUMMARY.md`
</output>
