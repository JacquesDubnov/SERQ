---
phase: 02-file-management
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - src/hooks/useAutoSave.ts
  - src/lib/recentFiles.ts
  - src/lib/workingFolder.ts
  - src/hooks/useFileOperations.ts
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Document auto-saves every 30 seconds when dirty and has a file path"
    - "Auto-save does NOT trigger on new unsaved documents (no path)"
    - "Auto-save debounces rapid changes (doesn't save on every keystroke)"
    - "Recent files list persists across app restarts"
    - "Opening a file adds it to recent files list"
    - "Recent files list is capped at 10 entries (FIFO)"
    - "Open/Save dialogs default to configured working folder"
    - "Working folder preference persists across app restarts"
  artifacts:
    - path: "src/hooks/useAutoSave.ts"
      provides: "Auto-save logic with 30-second debounce"
      exports: ["useAutoSave"]
      min_lines: 40
    - path: "src/lib/recentFiles.ts"
      provides: "Recent files persistence via tauri-plugin-store"
      exports: ["getRecentFiles", "addRecentFile", "clearRecentFiles", "removeRecentFile"]
      min_lines: 50
    - path: "src/lib/workingFolder.ts"
      provides: "Working folder preference via tauri-plugin-store"
      exports: ["getWorkingFolder", "setWorkingFolder"]
      min_lines: 20
  key_links:
    - from: "src/hooks/useAutoSave.ts"
      to: "@tauri-apps/plugin-fs"
      via: "writeTextFile for auto-save"
      pattern: "import.*from '@tauri-apps/plugin-fs'"
    - from: "src/hooks/useAutoSave.ts"
      to: "use-debounce"
      via: "useDebouncedCallback for 30-second delay"
      pattern: "useDebouncedCallback"
    - from: "src/lib/recentFiles.ts"
      to: "@tauri-apps/plugin-store"
      via: "load() for persistent preferences"
      pattern: "import.*from '@tauri-apps/plugin-store'"
    - from: "src/lib/workingFolder.ts"
      to: "@tauri-apps/plugin-store"
      via: "load() for persistent preferences"
      pattern: "import.*from '@tauri-apps/plugin-store'"
    - from: "src/hooks/useFileOperations.ts"
      to: "src/lib/recentFiles.ts"
      via: "addRecentFile on open/save"
      pattern: "import.*from.*recentFiles"
    - from: "src/hooks/useFileOperations.ts"
      to: "src/lib/workingFolder.ts"
      via: "getWorkingFolder for dialog defaultPath"
      pattern: "import.*from.*workingFolder"
---

<objective>
Add auto-save functionality with 30-second debounce, recent files list persistence, and working folder configuration.

Purpose: Prevents data loss from crashes/power failures (auto-save), improves UX by remembering recently opened files, and provides a configurable default folder for file dialogs.

Output:
- `useAutoSave` hook that saves dirty documents every 30 seconds
- `recentFiles.ts` library for persistent recent files list
- `workingFolder.ts` library for persistent working folder preference
- File operations updated to use working folder and track recent files
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-file-management/02-RESEARCH.md
@.planning/phases/02-file-management/02-02-SUMMARY.md

# Existing code to modify/integrate
@src/hooks/useFileOperations.ts
@src/stores/editorStore.ts
@src/lib/serqFormat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useAutoSave hook with debounce</name>
  <files>
    - src/hooks/useAutoSave.ts
    - src/hooks/index.ts
  </files>
  <action>
    Create `src/hooks/useAutoSave.ts`:

    The hook should:
    1. Accept `editorRef: React.RefObject<EditorCoreRef>` and optional `enabled: boolean = true`
    2. Use `useDebouncedCallback` from 'use-debounce' with 30000ms delay
    3. Track last save time via useRef
    4. Return `{ lastSave, flushAutoSave }`

    Implementation details:

    ```typescript
    const AUTO_SAVE_INTERVAL = 30000 // 30 seconds

    export function useAutoSave(
      editorRef: React.RefObject<EditorCoreRef>,
      enabled: boolean = true
    ) {
      const { document, markSaved } = useEditorStore()
      const lastSaveRef = useRef<Date | null>(null)

      const performAutoSave = useDebouncedCallback(
        async () => {
          // Guard conditions - don't auto-save if:
          // 1. No file path (new document, use Save As instead)
          // 2. Document isn't dirty (nothing to save)
          // 3. Editor ref isn't available
          if (!document.path || !document.isDirty) return
          if (!editorRef.current) return

          try {
            const html = editorRef.current.getHTML()
            const content = serializeSerqDocument(html, document)
            await writeTextFile(document.path, content)

            markSaved()
            lastSaveRef.current = new Date()
            console.log('[AutoSave] Document saved at', lastSaveRef.current)
          } catch (error) {
            console.error('[AutoSave] Failed:', error)
            // Don't mark as saved on error - user will see dirty indicator
          }
        },
        AUTO_SAVE_INTERVAL,
        { maxWait: AUTO_SAVE_INTERVAL * 2 } // Force save after 60s even if still typing
      )

      // Trigger auto-save when document becomes dirty
      useEffect(() => {
        if (enabled && document.isDirty && document.path) {
          performAutoSave()
        }
      }, [document.isDirty, document.path, enabled, performAutoSave])

      // Flush pending auto-save on unmount (app close)
      useEffect(() => {
        return () => {
          performAutoSave.flush()
        }
      }, [performAutoSave])

      return {
        lastSave: lastSaveRef.current,
        flushAutoSave: performAutoSave.flush,
      }
    }
    ```

    Key behaviors:
    - Auto-save only triggers when document has a path AND is dirty
    - 30-second debounce means rapid typing doesn't cause constant saves
    - maxWait of 60 seconds ensures save eventually happens during long typing sessions
    - Flush on unmount catches app close scenarios

    Update `src/hooks/index.ts` to export:
    ```typescript
    export { useAutoSave } from './useAutoSave'
    ```
  </action>
  <verify>
    - File exists at `src/hooks/useAutoSave.ts`
    - `npx tsc --noEmit` passes
    - Hook imports useDebouncedCallback from 'use-debounce'
    - Hook uses 30000ms (30 seconds) as interval
    - Hook is exported from index.ts
  </verify>
  <done>
    useAutoSave hook created with 30-second debounced auto-save that only triggers for saved documents with unsaved changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create recentFiles and workingFolder libraries</name>
  <files>
    - src/lib/recentFiles.ts
    - src/lib/workingFolder.ts
  </files>
  <action>
    Create `src/lib/recentFiles.ts`:

    ```typescript
    import { load } from '@tauri-apps/plugin-store'

    const MAX_RECENT_FILES = 10
    const STORE_FILE = 'preferences.json'

    interface RecentFile {
      path: string
      name: string
      lastOpened: string // ISO timestamp
    }

    let storeInstance: Awaited<ReturnType<typeof load>> | null = null

    async function getStore() {
      if (!storeInstance) {
        storeInstance = await load(STORE_FILE, { autoSave: false })
      }
      return storeInstance
    }

    export async function getRecentFiles(): Promise<RecentFile[]> {
      const store = await getStore()
      const files = await store.get<RecentFile[]>('recentFiles')
      return files ?? []
    }

    export async function addRecentFile(path: string, name: string): Promise<void> {
      const store = await getStore()
      let files = await getRecentFiles()

      // Remove if already exists (will re-add at top)
      files = files.filter(f => f.path !== path)

      // Add to front of list
      files.unshift({
        path,
        name,
        lastOpened: new Date().toISOString(),
      })

      // Trim to max (FIFO - oldest falls off)
      files = files.slice(0, MAX_RECENT_FILES)

      await store.set('recentFiles', files)
      await store.save()
    }

    export async function clearRecentFiles(): Promise<void> {
      const store = await getStore()
      await store.set('recentFiles', [])
      await store.save()
    }

    export async function removeRecentFile(path: string): Promise<void> {
      const store = await getStore()
      let files = await getRecentFiles()
      files = files.filter(f => f.path !== path)
      await store.set('recentFiles', files)
      await store.save()
    }

    export type { RecentFile }
    ```

    Create `src/lib/workingFolder.ts` (FILE-06 - Working folder config):

    ```typescript
    import { load } from '@tauri-apps/plugin-store'
    import { homeDir } from '@tauri-apps/api/path'

    const STORE_FILE = 'preferences.json'

    let storeInstance: Awaited<ReturnType<typeof load>> | null = null

    async function getStore() {
      if (!storeInstance) {
        storeInstance = await load(STORE_FILE, { autoSave: false })
      }
      return storeInstance
    }

    /**
     * Get the configured working folder for file dialogs.
     * Returns the stored preference, or falls back to user's home directory.
     */
    export async function getWorkingFolder(): Promise<string> {
      const store = await getStore()
      const folder = await store.get<string>('workingFolder')

      if (folder) {
        return folder
      }

      // Default to home directory if not configured
      return await homeDir()
    }

    /**
     * Set the working folder preference.
     * This will be used as defaultPath in open/save dialogs.
     */
    export async function setWorkingFolder(path: string): Promise<void> {
      const store = await getStore()
      await store.set('workingFolder', path)
      await store.save()
    }

    /**
     * Update working folder based on a file path.
     * Extracts the directory from the file path and stores it.
     */
    export async function updateWorkingFolderFromFile(filePath: string): Promise<void> {
      // Extract directory from file path
      const lastSlash = filePath.lastIndexOf('/')
      if (lastSlash > 0) {
        const directory = filePath.substring(0, lastSlash)
        await setWorkingFolder(directory)
      }
    }
    ```

    The working folder is used as `defaultPath` in file dialogs so they open to the user's preferred location. It updates automatically when files are opened or saved, remembering the last used directory.
  </action>
  <verify>
    - File exists at `src/lib/recentFiles.ts`
    - File exists at `src/lib/workingFolder.ts`
    - `npx tsc --noEmit` passes
    - recentFiles exports getRecentFiles, addRecentFile, clearRecentFiles, removeRecentFile
    - workingFolder exports getWorkingFolder, setWorkingFolder, updateWorkingFolderFromFile
  </verify>
  <done>
    Recent files and working folder persistence created. Both use tauri-plugin-store for persistence across app restarts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate recentFiles and workingFolder into file operations</name>
  <files>
    - src/hooks/useFileOperations.ts
  </files>
  <action>
    Update `src/hooks/useFileOperations.ts`:

    Add imports at top:
    ```typescript
    import { addRecentFile } from '../lib/recentFiles'
    import { getWorkingFolder, updateWorkingFolderFromFile } from '../lib/workingFolder'
    ```

    Update `openFile()` to use working folder and track recent files:
    ```typescript
    const openFile = async () => {
      // Get default path from working folder preference
      const defaultPath = await getWorkingFolder()

      const filePath = await open({
        multiple: false,
        directory: false,
        defaultPath,  // FILE-06: Use configured working folder
        filters: [{
          name: 'SERQ Documents',
          extensions: ['serq.html', 'html']
        }]
      })

      if (!filePath) return // User cancelled

      const content = await readTextFile(filePath as string)
      const { html, metadata } = parseSerqDocument(content)

      editorRef.current?.setContent(html)
      setDocument(filePath as string, extractFileName(filePath as string))

      // Add to recent files and update working folder
      await addRecentFile(filePath as string, extractFileName(filePath as string))
      await updateWorkingFolderFromFile(filePath as string)

      return { html, metadata }
    }
    ```

    Update `saveFileAs()` to use working folder and track recent files:
    ```typescript
    const saveFileAs = async () => {
      // Get default path from working folder preference
      const defaultPath = await getWorkingFolder()

      const filePath = await save({
        filters: [{
          name: 'SERQ Document',
          extensions: ['serq.html']
        }],
        defaultPath: defaultPath + '/Untitled.serq.html'  // FILE-06: Use configured working folder
      })

      if (!filePath) return // User cancelled

      const html = editorRef.current?.getHTML() ?? ''
      const content = serializeSerqDocument(html, { name: extractFileName(filePath) })

      await writeTextFile(filePath, content)
      setDocument(filePath, extractFileName(filePath))
      markSaved()

      // Add to recent files and update working folder
      await addRecentFile(filePath, extractFileName(filePath))
      await updateWorkingFolderFromFile(filePath)

      return filePath
    }
    ```

    Note: Regular `saveFile()` doesn't need to update recent files or working folder - the file was already opened/created from a known location.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - useFileOperations imports from recentFiles
    - useFileOperations imports from workingFolder
    - openFile calls getWorkingFolder and uses defaultPath
    - saveFileAs calls getWorkingFolder and uses defaultPath
    - Both openFile and saveFileAs call addRecentFile
    - Both openFile and saveFileAs call updateWorkingFolderFromFile
  </verify>
  <done>
    File operations integrated with recent files and working folder. Opening or saving-as a file adds it to recent files (max 10) and updates the working folder preference. Dialogs now default to the last used directory.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles: `npx tsc --noEmit`
2. Auto-save interval is 30000ms (30 seconds)
3. Recent files stored in preferences.json via tauri-plugin-store
4. Working folder stored in preferences.json via tauri-plugin-store
5. MAX_RECENT_FILES is 10
</verification>

<success_criteria>
- useAutoSave triggers only for dirty documents with existing file path
- Auto-save uses 30-second debounce with 60-second max wait
- Recent files list persists across app restarts
- Recent files capped at 10 entries
- Open and Save As operations add to recent files
- Open and Save As dialogs default to configured working folder
- Working folder updates when files are opened or saved
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-management/02-03-SUMMARY.md`
</output>
